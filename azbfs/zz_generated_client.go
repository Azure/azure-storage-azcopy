package azbfs

// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/azure-pipeline-go/pipeline"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"
)

const (
	// ServiceVersion specifies the version of the operations used in this package.
	ServiceVersion = "2018-03-28"
	//ServiceVersion = "2018-06-17" //TODO uncomment when service is ready
)

// managementClient is the base client for Azbfs.
type managementClient struct {
	url url.URL
	p   pipeline.Pipeline
}

// newManagementClient creates an instance of the managementClient client.
func newManagementClient(url url.URL, p pipeline.Pipeline) managementClient {
	return managementClient{
		url: url,
		p:   p,
	}
}

// URL returns a copy of the URL for this client.
func (mc managementClient) URL() url.URL {
	return mc.url
}

// Pipeline returns the pipeline for this client.
func (mc managementClient) Pipeline() pipeline.Pipeline {
	return mc.p
}

// CreateFilesystem create a filesystem rooted at the specified location. If the filesystem already exists, the
// operation fails.  This operation does not support conditional HTTP requests.
//
// filesystem is the filesystem identifier.  The value must start and end with a letter or number and must contain only
// letters, numbers, and the dash (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.
// The value must have between 3 and 63 characters. resource is the value must be "filesystem" for all filesystem
// operations. xMsProperties is user-defined properties to be stored with the filesystem, in the format of a
// comma-separated list of name and value pairs "n1=v1, n2=v2, ...", where each value is base64 encoded.
// xMsClientRequestID is a UUID recorded in the analytics logs for troubleshooting and correlation. timeout is an
// optional operation timeout value in seconds. The period begins when the request is received by the service. If the
// timeout value elapses before the operation completes, the operation fails. xMsDate is specifies the Coordinated
// Universal Time (UTC) for the request.  This is required when using shared key authorization.
func (client managementClient) CreateFilesystem(ctx context.Context, filesystem string, resource string, xMsProperties *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (*CreateFilesystemResponse, error) {
	if err := validate([]validation{
		{targetValue: xMsClientRequestID,
			constraints: []constraint{{target: "xMsClientRequestID", name: null, rule: false,
				chain: []constraint{{target: "xMsClientRequestID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil}}}}},
		{targetValue: timeout,
			constraints: []constraint{{target: "timeout", name: null, rule: false,
				chain: []constraint{{target: "timeout", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.createFilesystemPreparer(filesystem, resource, xMsProperties, xMsClientRequestID, timeout, xMsDate)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.createFilesystemResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*CreateFilesystemResponse), err
}

// createFilesystemPreparer prepares the CreateFilesystem request.
func (client managementClient) createFilesystemPreparer(filesystem string, resource string, xMsProperties *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("PUT", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("resource", resource)
	if timeout != nil {
		params.Set("timeout", strconv.FormatInt(int64(*timeout), 10))
	}
	req.URL.RawQuery = params.Encode()
	if xMsProperties != nil {
		req.Header.Set("x-ms-properties", *xMsProperties)
	}
	if xMsClientRequestID != nil {
		req.Header.Set("x-ms-client-request-id", *xMsClientRequestID)
	}
	if xMsDate != nil {
		req.Header.Set("x-ms-date", *xMsDate)
	}
	req.Header.Set("x-ms-version", ServiceVersion)
	return req, nil
}

// createFilesystemResponder handles the response to the CreateFilesystem request.
func (client managementClient) createFilesystemResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK, http.StatusCreated)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return &CreateFilesystemResponse{rawResponse: resp.Response()}, err
}

// CreatePath create or rename a file or directory.    By default, the destination is overwritten and if the
// destination already exists and has a lease the lease is broken.  This operation supports conditional HTTP requests.
// For more information, see [Specifying Conditional Headers for Blob Service
// Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
// To fail if the destination already exists, use a conditional request with If-None-Match: "*".
//
// filesystem is the filesystem identifier. pathParameter is the file or directory path. resource is required only for
// Create File and Create Directory. The value must be "file" or "directory". continuation is optional.  When renaming
// a directory, the number of paths that are renamed with each invocation is limited.  If the number of paths to be
// renamed exceeds this limit, a continuation token is returned in this response header.  When a continuation token is
// returned in the response, it must be specified in a subsequent invocation of the rename operation to continue
// renaming the directory. mode is optional. Valid only when namespace is enabled. This parameter determines the
// behavior of the rename operation. The value must be "legacy" or "posix", and the default value will be "posix".
// cacheControl is optional.  The service stores this value and includes it in the "Cache-Control" response header for
// "Read File" operations for "Read File" operations. contentEncoding is optional.  Specifies which content encodings
// have been applied to the file. This value is returned to the client when the "Read File" operation is performed.
// contentLanguage is optional.  Specifies the natural language used by the intended audience for the file.
// contentDisposition is optional.  The service stores this value and includes it in the "Content-Disposition" response
// header for "Read File" operations. xMsCacheControl is optional.  The service stores this value and includes it in
// the "Cache-Control" response header for "Read File" operations. xMsContentType is optional.  The service stores this
// value and includes it in the "Content-Type" response header for "Read File" operations. xMsContentEncoding is
// optional.  The service stores this value and includes it in the "Content-Encoding" response header for "Read File"
// operations. xMsContentLanguage is optional.  The service stores this value and includes it in the "Content-Language"
// response header for "Read File" operations. xMsContentDisposition is optional.  The service stores this value and
// includes it in the "Content-Disposition" response header for "Read File" operations. xMsRenameSource is an optional
// file or directory to be renamed.  The value must have the following format: "/{filesysystem}/{path}".  If
// "x-ms-properties" is specified, the properties will overwrite the existing properties; otherwise, the existing
// properties will be preserved. xMsLeaseID is optional.  A lease ID for the path specified in the URI.  The path to be
// overwritten must have an active lease and the lease ID must match. xMsProposedLeaseID is optional for create
// operations.  Required when "x-ms-lease-action" is used.  A lease will be acquired using the proposed ID when the
// resource is created. xMsSourceLeaseID is optional for rename operations.  A lease ID for the source path.  The
// source path must have an active lease and the lease ID must match. xMsProperties is optional.  User-defined
// properties to be stored with the file or directory, in the format of a comma-separated list of name and value pairs
// "n1=v1, n2=v2, ...", where each value is base64 encoded. xMsPermissions is optional and only valid if Hierarchical
// Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and
// others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both
// symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported. ifMatch is optional.  An ETag value.
// Specify this header to perform the operation only if the resource's ETag matches the value specified. The ETag must
// be specified in quotes. ifNoneMatch is optional.  An ETag value or the special wildcard ("*") value. Specify this
// header to perform the operation only if the resource's ETag does not match the value specified. The ETag must be
// specified in quotes. ifModifiedSince is optional. A date and time value. Specify this header to perform the
// operation only if the resource has been modified since the specified date and time. ifUnmodifiedSince is optional. A
// date and time value. Specify this header to perform the operation only if the resource has not been modified since
// the specified date and time. xMsSourceIfMatch is optional.  An ETag value. Specify this header to perform the rename
// operation only if the source's ETag matches the value specified. The ETag must be specified in quotes.
// xMsSourceIfNoneMatch is optional.  An ETag value or the special wildcard ("*") value. Specify this header to perform
// the rename operation only if the source's ETag does not match the value specified. The ETag must be specified in
// quotes. xMsSourceIfModifiedSince is optional. A date and time value. Specify this header to perform the rename
// operation only if the source has been modified since the specified date and time. xMsSourceIfUnmodifiedSince is
// optional. A date and time value. Specify this header to perform the rename operation only if the source has not been
// modified since the specified date and time. xMsClientRequestID is a UUID recorded in the analytics logs for
// troubleshooting and correlation. timeout is an optional operation timeout value in seconds. The period begins when
// the request is received by the service. If the timeout value elapses before the operation completes, the operation
// fails. xMsDate is specifies the Coordinated Universal Time (UTC) for the request.  This is required when using
// shared key authorization.
func (client managementClient) CreatePath(ctx context.Context, filesystem string, pathParameter string, resource *string, continuation *string, mode *string, cacheControl *string, contentEncoding *string, contentLanguage *string, contentDisposition *string, xMsCacheControl *string, xMsContentType *string, xMsContentEncoding *string, xMsContentLanguage *string, xMsContentDisposition *string, xMsRenameSource *string, xMsLeaseID *string, xMsProposedLeaseID *string, xMsSourceLeaseID *string, xMsProperties *string, xMsPermissions *string, ifMatch *string, ifNoneMatch *string, ifModifiedSince *string, ifUnmodifiedSince *string, xMsSourceIfMatch *string, xMsSourceIfNoneMatch *string, xMsSourceIfModifiedSince *string, xMsSourceIfUnmodifiedSince *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (*CreatePathResponse, error) {
	if err := validate([]validation{
		{targetValue: xMsLeaseID,
			constraints: []constraint{{target: "xMsLeaseID", name: null, rule: false,
				chain: []constraint{{target: "xMsLeaseID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil}}}}},
		{targetValue: xMsProposedLeaseID,
			constraints: []constraint{{target: "xMsProposedLeaseID", name: null, rule: false,
				chain: []constraint{{target: "xMsProposedLeaseID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil}}}}},
		{targetValue: xMsSourceLeaseID,
			constraints: []constraint{{target: "xMsSourceLeaseID", name: null, rule: false,
				chain: []constraint{{target: "xMsSourceLeaseID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil}}}}},
		{targetValue: filesystem,
			constraints: []constraint{{target: "filesystem", name: maxLength, rule: 63, chain: nil},
				{target: "filesystem", name: minLength, rule: 3, chain: nil}}},
		{targetValue: xMsClientRequestID,
			constraints: []constraint{{target: "xMsClientRequestID", name: null, rule: false,
				chain: []constraint{{target: "xMsClientRequestID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil}}}}},
		{targetValue: timeout,
			constraints: []constraint{{target: "timeout", name: null, rule: false,
				chain: []constraint{{target: "timeout", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.createPathPreparer(filesystem, pathParameter, resource, continuation, mode, cacheControl, contentEncoding, contentLanguage, contentDisposition, xMsCacheControl, xMsContentType, xMsContentEncoding, xMsContentLanguage, xMsContentDisposition, xMsRenameSource, xMsLeaseID, xMsProposedLeaseID, xMsSourceLeaseID, xMsProperties, xMsPermissions, ifMatch, ifNoneMatch, ifModifiedSince, ifUnmodifiedSince, xMsSourceIfMatch, xMsSourceIfNoneMatch, xMsSourceIfModifiedSince, xMsSourceIfUnmodifiedSince, xMsClientRequestID, timeout, xMsDate)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.createPathResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*CreatePathResponse), err
}

// createPathPreparer prepares the CreatePath request.
func (client managementClient) createPathPreparer(filesystem string, pathParameter string, resource *string, continuation *string, mode *string, cacheControl *string, contentEncoding *string, contentLanguage *string, contentDisposition *string, xMsCacheControl *string, xMsContentType *string, xMsContentEncoding *string, xMsContentLanguage *string, xMsContentDisposition *string, xMsRenameSource *string, xMsLeaseID *string, xMsProposedLeaseID *string, xMsSourceLeaseID *string, xMsProperties *string, xMsPermissions *string, ifMatch *string, ifNoneMatch *string, ifModifiedSince *string, ifUnmodifiedSince *string, xMsSourceIfMatch *string, xMsSourceIfNoneMatch *string, xMsSourceIfModifiedSince *string, xMsSourceIfUnmodifiedSince *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("PUT", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if resource != nil && len(*resource) > 0 {
		params.Set("resource", *resource)
	}
	if continuation != nil && len(*continuation) > 0 {
		params.Set("continuation", *continuation)
	}
	if mode != nil && len(*mode) > 0 {
		params.Set("mode", *mode)
	}
	if timeout != nil {
		params.Set("timeout", strconv.FormatInt(int64(*timeout), 10))
	}
	req.URL.RawQuery = params.Encode()
	if cacheControl != nil {
		req.Header.Set("Cache-Control", *cacheControl)
	}
	if contentEncoding != nil {
		req.Header.Set("Content-Encoding", *contentEncoding)
	}
	if contentLanguage != nil {
		req.Header.Set("Content-Language", *contentLanguage)
	}
	if contentDisposition != nil {
		req.Header.Set("Content-Disposition", *contentDisposition)
	}
	if xMsCacheControl != nil {
		req.Header.Set("x-ms-cache-control", *xMsCacheControl)
	}
	if xMsContentType != nil {
		req.Header.Set("x-ms-content-type", *xMsContentType)
	}
	if xMsContentEncoding != nil {
		req.Header.Set("x-ms-content-encoding", *xMsContentEncoding)
	}
	if xMsContentLanguage != nil {
		req.Header.Set("x-ms-content-language", *xMsContentLanguage)
	}
	if xMsContentDisposition != nil {
		req.Header.Set("x-ms-content-disposition", *xMsContentDisposition)
	}
	if xMsRenameSource != nil {
		req.Header.Set("x-ms-rename-source", *xMsRenameSource)
	}
	if xMsLeaseID != nil {
		req.Header.Set("x-ms-lease-id", *xMsLeaseID)
	}
	if xMsProposedLeaseID != nil {
		req.Header.Set("x-ms-proposed-lease-id", *xMsProposedLeaseID)
	}
	if xMsSourceLeaseID != nil {
		req.Header.Set("x-ms-source-lease-id", *xMsSourceLeaseID)
	}
	if xMsProperties != nil {
		req.Header.Set("x-ms-properties", *xMsProperties)
	}
	if xMsPermissions != nil {
		req.Header.Set("x-ms-permissions", *xMsPermissions)
	}
	if ifMatch != nil {
		req.Header.Set("If-Match", *ifMatch)
	}
	if ifNoneMatch != nil {
		req.Header.Set("If-None-Match", *ifNoneMatch)
	}
	if ifModifiedSince != nil {
		req.Header.Set("If-Modified-Since", *ifModifiedSince)
	}
	if ifUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", *ifUnmodifiedSince)
	}
	if xMsSourceIfMatch != nil {
		req.Header.Set("x-ms-source-if-match", *xMsSourceIfMatch)
	}
	if xMsSourceIfNoneMatch != nil {
		req.Header.Set("x-ms-source-if-none-match", *xMsSourceIfNoneMatch)
	}
	if xMsSourceIfModifiedSince != nil {
		req.Header.Set("x-ms-source-if-modified-since", *xMsSourceIfModifiedSince)
	}
	if xMsSourceIfUnmodifiedSince != nil {
		req.Header.Set("x-ms-source-if-unmodified-since", *xMsSourceIfUnmodifiedSince)
	}
	if xMsClientRequestID != nil {
		req.Header.Set("x-ms-client-request-id", *xMsClientRequestID)
	}
	if xMsDate != nil {
		req.Header.Set("x-ms-date", *xMsDate)
	}
	req.Header.Set("x-ms-version", ServiceVersion)
	return req, nil
}

// createPathResponder handles the response to the CreatePath request.
func (client managementClient) createPathResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK, http.StatusCreated)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return &CreatePathResponse{rawResponse: resp.Response()}, err
}

// DeleteFilesystem marks the filesystem for deletion.  When a filesystem is deleted, a filesystem with the same
// identifier cannot be created for at least 30 seconds. While the filesystem is being deleted, attempts to create a
// filesystem with the same identifier will fail with status code 409 (Conflict), with the service returning additional
// error information indicating that the filesystem is being deleted. All other operations, including operations on any
// files or directories within the filesystem, will fail with status code 404 (Not Found) while the filesystem is being
// deleted. This operation supports conditional HTTP requests.  For more information, see [Specifying Conditional
// Headers for Blob Service
// Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
//
// filesystem is the filesystem identifier.  The value must start and end with a letter or number and must contain only
// letters, numbers, and the dash (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.
// The value must have between 3 and 63 characters. resource is the value must be "filesystem" for all filesystem
// operations. ifModifiedSince is optional. A date and time value. Specify this header to perform the operation only if
// the resource has been modified since the specified date and time. ifUnmodifiedSince is optional. A date and time
// value. Specify this header to perform the operation only if the resource has not been modified since the specified
// date and time. xMsClientRequestID is a UUID recorded in the analytics logs for troubleshooting and correlation.
// timeout is an optional operation timeout value in seconds. The period begins when the request is received by the
// service. If the timeout value elapses before the operation completes, the operation fails. xMsDate is specifies the
// Coordinated Universal Time (UTC) for the request.  This is required when using shared key authorization.
func (client managementClient) DeleteFilesystem(ctx context.Context, filesystem string, resource string, ifModifiedSince *string, ifUnmodifiedSince *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (*DeleteFilesystemResponse, error) {
	if err := validate([]validation{
		{targetValue: xMsClientRequestID,
			constraints: []constraint{{target: "xMsClientRequestID", name: null, rule: false,
				chain: []constraint{{target: "xMsClientRequestID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil}}}}},
		{targetValue: timeout,
			constraints: []constraint{{target: "timeout", name: null, rule: false,
				chain: []constraint{{target: "timeout", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.deleteFilesystemPreparer(filesystem, resource, ifModifiedSince, ifUnmodifiedSince, xMsClientRequestID, timeout, xMsDate)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.deleteFilesystemResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*DeleteFilesystemResponse), err
}

// deleteFilesystemPreparer prepares the DeleteFilesystem request.
func (client managementClient) deleteFilesystemPreparer(filesystem string, resource string, ifModifiedSince *string, ifUnmodifiedSince *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("DELETE", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("resource", resource)
	if timeout != nil {
		params.Set("timeout", strconv.FormatInt(int64(*timeout), 10))
	}
	req.URL.RawQuery = params.Encode()
	if ifModifiedSince != nil {
		req.Header.Set("If-Modified-Since", *ifModifiedSince)
	}
	if ifUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", *ifUnmodifiedSince)
	}
	if xMsClientRequestID != nil {
		req.Header.Set("x-ms-client-request-id", *xMsClientRequestID)
	}
	if xMsDate != nil {
		req.Header.Set("x-ms-date", *xMsDate)
	}
	req.Header.Set("x-ms-version", ServiceVersion)
	return req, nil
}

// deleteFilesystemResponder handles the response to the DeleteFilesystem request.
func (client managementClient) deleteFilesystemResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK, http.StatusAccepted)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return &DeleteFilesystemResponse{rawResponse: resp.Response()}, err
}

// DeletePath delete the file or directory. This operation supports conditional HTTP requests.  For more information,
// see [Specifying Conditional Headers for Blob Service
// Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
//
// filesystem is the filesystem identifier. pathParameter is the file or directory path. recursive is required and
// valid only when the resource is a directory.  If "true", all paths beneath the directory will be deleted. If "false"
// and the directory is non-empty, an error occurs. continuation is optional.  When deleting a directory, the number of
// paths that are deleted with each invocation is limited.  If the number of paths to be deleted exceeds this limit, a
// continuation token is returned in this response header.  When a continuation token is returned in the response, it
// must be specified in a subsequent invocation of the delete operation to continue deleting the directory. xMsLeaseID
// is the lease ID must be specified if there is an active lease. ifMatch is optional.  An ETag value. Specify this
// header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified
// in quotes. ifNoneMatch is optional.  An ETag value or the special wildcard ("*") value. Specify this header to
// perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in
// quotes. ifModifiedSince is optional. A date and time value. Specify this header to perform the operation only if the
// resource has been modified since the specified date and time. ifUnmodifiedSince is optional. A date and time value.
// Specify this header to perform the operation only if the resource has not been modified since the specified date and
// time. xMsClientRequestID is a UUID recorded in the analytics logs for troubleshooting and correlation. timeout is an
// optional operation timeout value in seconds. The period begins when the request is received by the service. If the
// timeout value elapses before the operation completes, the operation fails. xMsDate is specifies the Coordinated
// Universal Time (UTC) for the request.  This is required when using shared key authorization.
func (client managementClient) DeletePath(ctx context.Context, filesystem string, pathParameter string, recursive *bool, continuation *string, xMsLeaseID *string, ifMatch *string, ifNoneMatch *string, ifModifiedSince *string, ifUnmodifiedSince *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (*DeletePathResponse, error) {
	if err := validate([]validation{
		{targetValue: xMsLeaseID,
			constraints: []constraint{{target: "xMsLeaseID", name: null, rule: false,
				chain: []constraint{{target: "xMsLeaseID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil}}}}},
		{targetValue: filesystem,
			constraints: []constraint{{target: "filesystem", name: maxLength, rule: 63, chain: nil},
				{target: "filesystem", name: minLength, rule: 3, chain: nil}}},
		{targetValue: xMsClientRequestID,
			constraints: []constraint{{target: "xMsClientRequestID", name: null, rule: false,
				chain: []constraint{{target: "xMsClientRequestID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil}}}}},
		{targetValue: timeout,
			constraints: []constraint{{target: "timeout", name: null, rule: false,
				chain: []constraint{{target: "timeout", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.deletePathPreparer(filesystem, pathParameter, recursive, continuation, xMsLeaseID, ifMatch, ifNoneMatch, ifModifiedSince, ifUnmodifiedSince, xMsClientRequestID, timeout, xMsDate)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.deletePathResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*DeletePathResponse), err
}

// deletePathPreparer prepares the DeletePath request.
func (client managementClient) deletePathPreparer(filesystem string, pathParameter string, recursive *bool, continuation *string, xMsLeaseID *string, ifMatch *string, ifNoneMatch *string, ifModifiedSince *string, ifUnmodifiedSince *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("DELETE", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if recursive != nil {
		params.Set("recursive", strconv.FormatBool(*recursive))
	}
	if continuation != nil && len(*continuation) > 0 {
		params.Set("continuation", *continuation)
	}
	if timeout != nil {
		params.Set("timeout", strconv.FormatInt(int64(*timeout), 10))
	}
	req.URL.RawQuery = params.Encode()
	if xMsLeaseID != nil {
		req.Header.Set("x-ms-lease-id", *xMsLeaseID)
	}
	if ifMatch != nil {
		req.Header.Set("If-Match", *ifMatch)
	}
	if ifNoneMatch != nil {
		req.Header.Set("If-None-Match", *ifNoneMatch)
	}
	if ifModifiedSince != nil {
		req.Header.Set("If-Modified-Since", *ifModifiedSince)
	}
	if ifUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", *ifUnmodifiedSince)
	}
	if xMsClientRequestID != nil {
		req.Header.Set("x-ms-client-request-id", *xMsClientRequestID)
	}
	if xMsDate != nil {
		req.Header.Set("x-ms-date", *xMsDate)
	}
	req.Header.Set("x-ms-version", ServiceVersion)
	return req, nil
}

// deletePathResponder handles the response to the DeletePath request.
func (client managementClient) deletePathResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return &DeletePathResponse{rawResponse: resp.Response()}, err
}

// GetFilesystemProperties all system and user-defined filesystem properties are specified in the response headers.
//
// filesystem is the filesystem identifier.  The value must start and end with a letter or number and must contain only
// letters, numbers, and the dash (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.
// The value must have between 3 and 63 characters. resource is the value must be "filesystem" for all filesystem
// operations. xMsClientRequestID is a UUID recorded in the analytics logs for troubleshooting and correlation. timeout
// is an optional operation timeout value in seconds. The period begins when the request is received by the service. If
// the timeout value elapses before the operation completes, the operation fails. xMsDate is specifies the Coordinated
// Universal Time (UTC) for the request.  This is required when using shared key authorization.
func (client managementClient) GetFilesystemProperties(ctx context.Context, filesystem string, resource string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (*GetFilesystemPropertiesResponse, error) {
	if err := validate([]validation{
		{targetValue: xMsClientRequestID,
			constraints: []constraint{{target: "xMsClientRequestID", name: null, rule: false,
				chain: []constraint{{target: "xMsClientRequestID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil}}}}},
		{targetValue: timeout,
			constraints: []constraint{{target: "timeout", name: null, rule: false,
				chain: []constraint{{target: "timeout", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.getFilesystemPropertiesPreparer(filesystem, resource, xMsClientRequestID, timeout, xMsDate)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getFilesystemPropertiesResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetFilesystemPropertiesResponse), err
}

// getFilesystemPropertiesPreparer prepares the GetFilesystemProperties request.
func (client managementClient) getFilesystemPropertiesPreparer(filesystem string, resource string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("HEAD", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("resource", resource)
	if timeout != nil {
		params.Set("timeout", strconv.FormatInt(int64(*timeout), 10))
	}
	req.URL.RawQuery = params.Encode()
	if xMsClientRequestID != nil {
		req.Header.Set("x-ms-client-request-id", *xMsClientRequestID)
	}
	if xMsDate != nil {
		req.Header.Set("x-ms-date", *xMsDate)
	}
	req.Header.Set("x-ms-version", ServiceVersion)
	return req, nil
}

// getFilesystemPropertiesResponder handles the response to the GetFilesystemProperties request.
func (client managementClient) getFilesystemPropertiesResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return &GetFilesystemPropertiesResponse{rawResponse: resp.Response()}, err
}

// GetPathProperties get the properties for a file or directory, and optionally include the access control list.  This
// operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob
// Service
// Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
//
// filesystem is the filesystem identifier. pathParameter is the file or directory path. action is optional. If the
// value is "getAccessControl" the access control list is returned in the response headers (Hierarchical Namespace must
// be enabled for the account). ifMatch is optional.  An ETag value. Specify this header to perform the operation only
// if the resource's ETag matches the value specified. The ETag must be specified in quotes. ifNoneMatch is optional.
// An ETag value or the special wildcard ("*") value. Specify this header to perform the operation only if the
// resource's ETag does not match the value specified. The ETag must be specified in quotes. ifModifiedSince is
// optional. A date and time value. Specify this header to perform the operation only if the resource has been modified
// since the specified date and time. ifUnmodifiedSince is optional. A date and time value. Specify this header to
// perform the operation only if the resource has not been modified since the specified date and time.
// xMsClientRequestID is a UUID recorded in the analytics logs for troubleshooting and correlation. timeout is an
// optional operation timeout value in seconds. The period begins when the request is received by the service. If the
// timeout value elapses before the operation completes, the operation fails. xMsDate is specifies the Coordinated
// Universal Time (UTC) for the request.  This is required when using shared key authorization.
func (client managementClient) GetPathProperties(ctx context.Context, filesystem string, pathParameter string, action *string, ifMatch *string, ifNoneMatch *string, ifModifiedSince *string, ifUnmodifiedSince *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (*GetPathPropertiesResponse, error) {
	if err := validate([]validation{
		{targetValue: filesystem,
			constraints: []constraint{{target: "filesystem", name: maxLength, rule: 63, chain: nil},
				{target: "filesystem", name: minLength, rule: 3, chain: nil}}},
		{targetValue: xMsClientRequestID,
			constraints: []constraint{{target: "xMsClientRequestID", name: null, rule: false,
				chain: []constraint{{target: "xMsClientRequestID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil}}}}},
		{targetValue: timeout,
			constraints: []constraint{{target: "timeout", name: null, rule: false,
				chain: []constraint{{target: "timeout", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.getPathPropertiesPreparer(filesystem, pathParameter, action, ifMatch, ifNoneMatch, ifModifiedSince, ifUnmodifiedSince, xMsClientRequestID, timeout, xMsDate)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getPathPropertiesResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*GetPathPropertiesResponse), err
}

// getPathPropertiesPreparer prepares the GetPathProperties request.
func (client managementClient) getPathPropertiesPreparer(filesystem string, pathParameter string, action *string, ifMatch *string, ifNoneMatch *string, ifModifiedSince *string, ifUnmodifiedSince *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("HEAD", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if action != nil && len(*action) > 0 {
		params.Set("action", *action)
	}
	if timeout != nil {
		params.Set("timeout", strconv.FormatInt(int64(*timeout), 10))
	}
	req.URL.RawQuery = params.Encode()
	if ifMatch != nil {
		req.Header.Set("If-Match", *ifMatch)
	}
	if ifNoneMatch != nil {
		req.Header.Set("If-None-Match", *ifNoneMatch)
	}
	if ifModifiedSince != nil {
		req.Header.Set("If-Modified-Since", *ifModifiedSince)
	}
	if ifUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", *ifUnmodifiedSince)
	}
	if xMsClientRequestID != nil {
		req.Header.Set("x-ms-client-request-id", *xMsClientRequestID)
	}
	if xMsDate != nil {
		req.Header.Set("x-ms-date", *xMsDate)
	}
	req.Header.Set("x-ms-version", ServiceVersion)
	return req, nil
}

// getPathPropertiesResponder handles the response to the GetPathProperties request.
func (client managementClient) getPathPropertiesResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return &GetPathPropertiesResponse{rawResponse: resp.Response()}, err
}

// LeasePath create and manage a lease to restrict write and delete access to the path. This operation supports
// conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service
// Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
//
// xMsLeaseAction is there are five lease actions: "acquire", "break", "change", "renew", and "release". Use "acquire"
// and specify the "x-ms-proposed-lease-id" and "x-ms-lease-duration" to acquire a new lease. Use "break" to break an
// existing lease. When a lease is broken, the lease break period is allowed to elapse, during which time no lease
// operation except break and release can be performed on the file. When a lease is successfully broken, the response
// indicates the interval in seconds until a new lease can be acquired. Use "change" and specify the current lease ID
// in "x-ms-lease-id" and the new lease ID in "x-ms-proposed-lease-id" to change the lease ID of an active lease. Use
// "renew" and specify the "x-ms-lease-id" to renew an existing lease. Use "release" and specify the "x-ms-lease-id" to
// release a lease. filesystem is the filesystem identifier. pathParameter is the file or directory path.
// xMsLeaseDuration is the lease duration is required to acquire a lease, and specifies the duration of the lease in
// seconds.  The lease duration must be between 15 and 60 seconds or -1 for infinite lease. xMsLeaseBreakPeriod is the
// lease break period duration is optional to break a lease, and  specifies the break period of the lease in seconds.
// The lease break  duration must be between 0 and 60 seconds. xMsLeaseID is required when "x-ms-lease-action" is
// "renew", "change" or "release". For the renew and release actions, this must match the current lease ID.
// xMsProposedLeaseID is required when "x-ms-lease-action" is "acquire" or "change".  A lease will be acquired with
// this lease ID if the operation is successful. ifMatch is optional.  An ETag value. Specify this header to perform
// the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.
// ifNoneMatch is optional.  An ETag value or the special wildcard ("*") value. Specify this header to perform the
// operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.
// ifModifiedSince is optional. A date and time value. Specify this header to perform the operation only if the
// resource has been modified since the specified date and time. ifUnmodifiedSince is optional. A date and time value.
// Specify this header to perform the operation only if the resource has not been modified since the specified date and
// time. xMsClientRequestID is a UUID recorded in the analytics logs for troubleshooting and correlation. timeout is an
// optional operation timeout value in seconds. The period begins when the request is received by the service. If the
// timeout value elapses before the operation completes, the operation fails. xMsDate is specifies the Coordinated
// Universal Time (UTC) for the request.  This is required when using shared key authorization.
func (client managementClient) LeasePath(ctx context.Context, xMsLeaseAction string, filesystem string, pathParameter string, xMsLeaseDuration *int32, xMsLeaseBreakPeriod *int32, xMsLeaseID *string, xMsProposedLeaseID *string, ifMatch *string, ifNoneMatch *string, ifModifiedSince *string, ifUnmodifiedSince *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (*LeasePathResponse, error) {
	if err := validate([]validation{
		{targetValue: xMsLeaseID,
			constraints: []constraint{{target: "xMsLeaseID", name: null, rule: false,
				chain: []constraint{{target: "xMsLeaseID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil}}}}},
		{targetValue: xMsProposedLeaseID,
			constraints: []constraint{{target: "xMsProposedLeaseID", name: null, rule: false,
				chain: []constraint{{target: "xMsProposedLeaseID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil}}}}},
		{targetValue: filesystem,
			constraints: []constraint{{target: "filesystem", name: maxLength, rule: 63, chain: nil},
				{target: "filesystem", name: minLength, rule: 3, chain: nil}}},
		{targetValue: xMsClientRequestID,
			constraints: []constraint{{target: "xMsClientRequestID", name: null, rule: false,
				chain: []constraint{{target: "xMsClientRequestID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil}}}}},
		{targetValue: timeout,
			constraints: []constraint{{target: "timeout", name: null, rule: false,
				chain: []constraint{{target: "timeout", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.leasePathPreparer(xMsLeaseAction, filesystem, pathParameter, xMsLeaseDuration, xMsLeaseBreakPeriod, xMsLeaseID, xMsProposedLeaseID, ifMatch, ifNoneMatch, ifModifiedSince, ifUnmodifiedSince, xMsClientRequestID, timeout, xMsDate)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.leasePathResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*LeasePathResponse), err
}

// leasePathPreparer prepares the LeasePath request.
func (client managementClient) leasePathPreparer(xMsLeaseAction string, filesystem string, pathParameter string, xMsLeaseDuration *int32, xMsLeaseBreakPeriod *int32, xMsLeaseID *string, xMsProposedLeaseID *string, ifMatch *string, ifNoneMatch *string, ifModifiedSince *string, ifUnmodifiedSince *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if timeout != nil {
		params.Set("timeout", strconv.FormatInt(int64(*timeout), 10))
	}
	req.URL.RawQuery = params.Encode()
	req.Header.Set("x-ms-lease-action", xMsLeaseAction)
	if xMsLeaseDuration != nil {
		req.Header.Set("x-ms-lease-duration", strconv.FormatInt(int64(*xMsLeaseDuration), 10))
	}
	if xMsLeaseBreakPeriod != nil {
		req.Header.Set("x-ms-lease-break-period", strconv.FormatInt(int64(*xMsLeaseBreakPeriod), 10))
	}
	if xMsLeaseID != nil {
		req.Header.Set("x-ms-lease-id", *xMsLeaseID)
	}
	if xMsProposedLeaseID != nil {
		req.Header.Set("x-ms-proposed-lease-id", *xMsProposedLeaseID)
	}
	if ifMatch != nil {
		req.Header.Set("If-Match", *ifMatch)
	}
	if ifNoneMatch != nil {
		req.Header.Set("If-None-Match", *ifNoneMatch)
	}
	if ifModifiedSince != nil {
		req.Header.Set("If-Modified-Since", *ifModifiedSince)
	}
	if ifUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", *ifUnmodifiedSince)
	}
	if xMsClientRequestID != nil {
		req.Header.Set("x-ms-client-request-id", *xMsClientRequestID)
	}
	if xMsDate != nil {
		req.Header.Set("x-ms-date", *xMsDate)
	}
	req.Header.Set("x-ms-version", ServiceVersion)
	return req, nil
}

// leasePathResponder handles the response to the LeasePath request.
func (client managementClient) leasePathResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK, http.StatusCreated, http.StatusAccepted)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return &LeasePathResponse{rawResponse: resp.Response()}, err
}

// ListFilesystems list filesystems and their properties in given account.
//
// resource is the value must be "account" for all account operations. prefix is filters results to filesystems within
// the specified prefix. continuation is the number of filesystems returned with each invocation is limited. If the
// number of filesystems to be returned exceeds this limit, a continuation token is returned in the response header
// x-ms-continuation. When a continuation token is  returned in the response, it must be specified in a subsequent
// invocation of the list operation to continue listing the filesystems. maxResults is an optional value that specifies
// the maximum number of items to return. If omitted or greater than 5,000, the response will include up to 5,000
// items. xMsClientRequestID is a UUID recorded in the analytics logs for troubleshooting and correlation. timeout is
// an optional operation timeout value in seconds. The period begins when the request is received by the service. If
// the timeout value elapses before the operation completes, the operation fails. xMsDate is specifies the Coordinated
// Universal Time (UTC) for the request.  This is required when using shared key authorization.
func (client managementClient) ListFilesystems(ctx context.Context, resource string, prefix *string, continuation *string, maxResults *int32, xMsClientRequestID *string, timeout *int32, xMsDate *string) (*ListFilesystemSchema, error) {
	if err := validate([]validation{
		{targetValue: maxResults,
			constraints: []constraint{{target: "maxResults", name: null, rule: false,
				chain: []constraint{{target: "maxResults", name: inclusiveMinimum, rule: 1, chain: nil}}}}},
		{targetValue: xMsClientRequestID,
			constraints: []constraint{{target: "xMsClientRequestID", name: null, rule: false,
				chain: []constraint{{target: "xMsClientRequestID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil}}}}},
		{targetValue: timeout,
			constraints: []constraint{{target: "timeout", name: null, rule: false,
				chain: []constraint{{target: "timeout", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.listFilesystemsPreparer(resource, prefix, continuation, maxResults, xMsClientRequestID, timeout, xMsDate)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listFilesystemsResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*ListFilesystemSchema), err
}

// listFilesystemsPreparer prepares the ListFilesystems request.
func (client managementClient) listFilesystemsPreparer(resource string, prefix *string, continuation *string, maxResults *int32, xMsClientRequestID *string, timeout *int32, xMsDate *string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("resource", resource)
	if prefix != nil && len(*prefix) > 0 {
		params.Set("prefix", *prefix)
	}
	if continuation != nil && len(*continuation) > 0 {
		params.Set("continuation", *continuation)
	}
	if maxResults != nil {
		params.Set("maxResults", strconv.FormatInt(int64(*maxResults), 10))
	}
	if timeout != nil {
		params.Set("timeout", strconv.FormatInt(int64(*timeout), 10))
	}
	req.URL.RawQuery = params.Encode()
	if xMsClientRequestID != nil {
		req.Header.Set("x-ms-client-request-id", *xMsClientRequestID)
	}
	if xMsDate != nil {
		req.Header.Set("x-ms-date", *xMsDate)
	}
	req.Header.Set("x-ms-version", ServiceVersion)
	return req, nil
}

// listFilesystemsResponder handles the response to the ListFilesystems request.
func (client managementClient) listFilesystemsResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &ListFilesystemSchema{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ListPaths list filesystem paths and their properties.
//
// recursive is if "true", all paths are listed; otherwise, only paths at the root of the filesystem are listed.  If
// "directory" is specified, the list will only include paths that share the same root. filesystem is the filesystem
// identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the
// dash (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have
// between 3 and 63 characters. resource is the value must be "filesystem" for all filesystem operations. directory is
// filters results to paths within the specified directory. An error occurs if the directory does not exist.
// continuation is the number of paths returned with each invocation is limited. If the number of paths to be returned
// exceeds this limit, a continuation token is returned in the response header x-ms-continuation. When a continuation
// token is  returned in the response, it must be specified in a subsequent invocation of the list operation to
// continue listing the paths. maxResults is an optional value that specifies the maximum number of items to return. If
// omitted or greater than 5,000, the response will include up to 5,000 items. xMsClientRequestID is a UUID recorded in
// the analytics logs for troubleshooting and correlation. timeout is an optional operation timeout value in seconds.
// The period begins when the request is received by the service. If the timeout value elapses before the operation
// completes, the operation fails. xMsDate is specifies the Coordinated Universal Time (UTC) for the request.  This is
// required when using shared key authorization.
func (client managementClient) ListPaths(ctx context.Context, recursive bool, filesystem string, resource string, directory *string, continuation *string, maxResults *int32, xMsClientRequestID *string, timeout *int32, xMsDate *string) (*ListSchema, error) {
	if err := validate([]validation{
		{targetValue: maxResults,
			constraints: []constraint{{target: "maxResults", name: null, rule: false,
				chain: []constraint{{target: "maxResults", name: inclusiveMinimum, rule: 1, chain: nil}}}}},
		{targetValue: xMsClientRequestID,
			constraints: []constraint{{target: "xMsClientRequestID", name: null, rule: false,
				chain: []constraint{{target: "xMsClientRequestID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil}}}}},
		{targetValue: timeout,
			constraints: []constraint{{target: "timeout", name: null, rule: false,
				chain: []constraint{{target: "timeout", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.listPathsPreparer(recursive, filesystem, resource, directory, continuation, maxResults, xMsClientRequestID, timeout, xMsDate)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listPathsResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*ListSchema), err
}

// listPathsPreparer prepares the ListPaths request.
func (client managementClient) listPathsPreparer(recursive bool, filesystem string, resource string, directory *string, continuation *string, maxResults *int32, xMsClientRequestID *string, timeout *int32, xMsDate *string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if directory != nil && len(*directory) > 0 {
		params.Set("directory", *directory)
	}
	params.Set("recursive", strconv.FormatBool(recursive))
	if continuation != nil && len(*continuation) > 0 {
		params.Set("continuation", *continuation)
	}
	if maxResults != nil {
		params.Set("maxResults", strconv.FormatInt(int64(*maxResults), 10))
	}
	params.Set("resource", resource)
	if timeout != nil {
		params.Set("timeout", strconv.FormatInt(int64(*timeout), 10))
	}
	req.URL.RawQuery = params.Encode()
	if xMsClientRequestID != nil {
		req.Header.Set("x-ms-client-request-id", *xMsClientRequestID)
	}
	if xMsDate != nil {
		req.Header.Set("x-ms-date", *xMsDate)
	}
	req.Header.Set("x-ms-version", ServiceVersion)
	return req, nil
}

// listPathsResponder handles the response to the ListPaths request.
func (client managementClient) listPathsResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	result := &ListSchema{rawResponse: resp.Response()}
	if err != nil {
		return result, err
	}
	defer resp.Response().Body.Close()
	b, err := ioutil.ReadAll(resp.Response().Body)
	if err != nil {
		return result, NewResponseError(err, resp.Response(), "failed to read response body")
	}
	if len(b) > 0 {
		b = removeBOM(b)
		err = json.Unmarshal(b, result)
		if err != nil {
			return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
		}
	}
	return result, nil
}

// ReadPath read the contents of a file.  For read operations, range requests are supported. This operation supports
// conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service
// Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
//
// filesystem is the filesystem identifier. pathParameter is the file or directory path. rangeParameter is the HTTP
// Range request header specifies one or more byte ranges of the resource to be retrieved. ifMatch is optional.  An
// ETag value. Specify this header to perform the operation only if the resource's ETag matches the value specified.
// The ETag must be specified in quotes. ifNoneMatch is optional.  An ETag value or the special wildcard ("*") value.
// Specify this header to perform the operation only if the resource's ETag does not match the value specified. The
// ETag must be specified in quotes. ifModifiedSince is optional. A date and time value. Specify this header to perform
// the operation only if the resource has been modified since the specified date and time. ifUnmodifiedSince is
// optional. A date and time value. Specify this header to perform the operation only if the resource has not been
// modified since the specified date and time. xMsClientRequestID is a UUID recorded in the analytics logs for
// troubleshooting and correlation. timeout is an optional operation timeout value in seconds. The period begins when
// the request is received by the service. If the timeout value elapses before the operation completes, the operation
// fails. xMsDate is specifies the Coordinated Universal Time (UTC) for the request.  This is required when using
// shared key authorization.
func (client managementClient) ReadPath(ctx context.Context, filesystem string, pathParameter string, rangeParameter *string, ifMatch *string, ifNoneMatch *string, ifModifiedSince *string, ifUnmodifiedSince *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (*ReadPathResponse, error) {
	if err := validate([]validation{
		{targetValue: filesystem,
			constraints: []constraint{{target: "filesystem", name: maxLength, rule: 63, chain: nil},
				{target: "filesystem", name: minLength, rule: 3, chain: nil}}},
		{targetValue: xMsClientRequestID,
			constraints: []constraint{{target: "xMsClientRequestID", name: null, rule: false,
				chain: []constraint{{target: "xMsClientRequestID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil}}}}},
		{targetValue: timeout,
			constraints: []constraint{{target: "timeout", name: null, rule: false,
				chain: []constraint{{target: "timeout", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.readPathPreparer(filesystem, pathParameter, rangeParameter, ifMatch, ifNoneMatch, ifModifiedSince, ifUnmodifiedSince, xMsClientRequestID, timeout, xMsDate)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.readPathResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*ReadPathResponse), err
}

// readPathPreparer prepares the ReadPath request.
func (client managementClient) readPathPreparer(filesystem string, pathParameter string, rangeParameter *string, ifMatch *string, ifNoneMatch *string, ifModifiedSince *string, ifUnmodifiedSince *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	if timeout != nil {
		params.Set("timeout", strconv.FormatInt(int64(*timeout), 10))
	}
	req.URL.RawQuery = params.Encode()
	if rangeParameter != nil {
		req.Header.Set("Range", *rangeParameter)
	}
	if ifMatch != nil {
		req.Header.Set("If-Match", *ifMatch)
	}
	if ifNoneMatch != nil {
		req.Header.Set("If-None-Match", *ifNoneMatch)
	}
	if ifModifiedSince != nil {
		req.Header.Set("If-Modified-Since", *ifModifiedSince)
	}
	if ifUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", *ifUnmodifiedSince)
	}
	if xMsClientRequestID != nil {
		req.Header.Set("x-ms-client-request-id", *xMsClientRequestID)
	}
	if xMsDate != nil {
		req.Header.Set("x-ms-date", *xMsDate)
	}
	req.Header.Set("x-ms-version", ServiceVersion)
	return req, nil
}

// readPathResponder handles the response to the ReadPath request.
func (client managementClient) readPathResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK, http.StatusPartialContent)
	if resp == nil {
		return nil, err
	}
	return &ReadPathResponse{rawResponse: resp.Response()}, err
}

// SetFilesystemProperties set properties for the filesystem.  This operation supports conditional HTTP requests.  For
// more information, see [Specifying Conditional Headers for Blob Service
// Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
//
// filesystem is the filesystem identifier.  The value must start and end with a letter or number and must contain only
// letters, numbers, and the dash (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.
// The value must have between 3 and 63 characters. resource is the value must be "filesystem" for all filesystem
// operations. xMsProperties is optional. User-defined properties to be stored with the filesystem, in the format of a
// comma-separated list of name and value pairs "n1=v1, n2=v2, ...", where each value is base64 encoded.  If the
// filesystem exists, any properties not included in the list will be removed.  All properties are removed if the
// header is omitted.  To merge new and existing properties, first get all existing properties and the current E-Tag,
// then make a conditional request with the E-Tag and include values for all properties. ifModifiedSince is optional. A
// date and time value. Specify this header to perform the operation only if the resource has been modified since the
// specified date and time. ifUnmodifiedSince is optional. A date and time value. Specify this header to perform the
// operation only if the resource has not been modified since the specified date and time. xMsClientRequestID is a UUID
// recorded in the analytics logs for troubleshooting and correlation. timeout is an optional operation timeout value
// in seconds. The period begins when the request is received by the service. If the timeout value elapses before the
// operation completes, the operation fails. xMsDate is specifies the Coordinated Universal Time (UTC) for the request.
// This is required when using shared key authorization.
func (client managementClient) SetFilesystemProperties(ctx context.Context, filesystem string, resource string, xMsProperties *string, ifModifiedSince *string, ifUnmodifiedSince *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (*SetFilesystemPropertiesResponse, error) {
	if err := validate([]validation{
		{targetValue: xMsClientRequestID,
			constraints: []constraint{{target: "xMsClientRequestID", name: null, rule: false,
				chain: []constraint{{target: "xMsClientRequestID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil}}}}},
		{targetValue: timeout,
			constraints: []constraint{{target: "timeout", name: null, rule: false,
				chain: []constraint{{target: "timeout", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.setFilesystemPropertiesPreparer(filesystem, resource, xMsProperties, ifModifiedSince, ifUnmodifiedSince, xMsClientRequestID, timeout, xMsDate)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.setFilesystemPropertiesResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*SetFilesystemPropertiesResponse), err
}

// setFilesystemPropertiesPreparer prepares the SetFilesystemProperties request.
func (client managementClient) setFilesystemPropertiesPreparer(filesystem string, resource string, xMsProperties *string, ifModifiedSince *string, ifUnmodifiedSince *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("PATCH", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("resource", resource)
	if timeout != nil {
		params.Set("timeout", strconv.FormatInt(int64(*timeout), 10))
	}
	req.URL.RawQuery = params.Encode()
	if xMsProperties != nil {
		req.Header.Set("x-ms-properties", *xMsProperties)
	}
	if ifModifiedSince != nil {
		req.Header.Set("If-Modified-Since", *ifModifiedSince)
	}
	if ifUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", *ifUnmodifiedSince)
	}
	if xMsClientRequestID != nil {
		req.Header.Set("x-ms-client-request-id", *xMsClientRequestID)
	}
	if xMsDate != nil {
		req.Header.Set("x-ms-date", *xMsDate)
	}
	req.Header.Set("x-ms-version", ServiceVersion)
	return req, nil
}

// setFilesystemPropertiesResponder handles the response to the SetFilesystemProperties request.
func (client managementClient) setFilesystemPropertiesResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return &SetFilesystemPropertiesResponse{rawResponse: resp.Response()}, err
}

// UpdatePath uploads data to be appended to a file, flushes (writes) previously uploaded data to a file, sets
// properties for a file or directory, or sets access control for a file or directory. Data can only be appended to a
// file. This operation supports conditional HTTP requests. For more information, see [Specifying Conditional Headers
// for Blob Service
// Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
//
// action is the action must be "append" to upload data to be appended to a file, "flush" to flush previously uploaded
// data to a file, "setProperties" to set the properties of a file or directory, or "setAccessControl" to set the
// owner, group, permissions, or access control list for a file or directory.  Note that Hierarchical Namespace must be
// enabled for the account in order to use access control.  Also note that the Access Control List (ACL) includes
// permissions for the owner, owning group, and others, so the x-ms-permissions and x-ms-acl request headers are
// mutually exclusive. filesystem is the filesystem identifier. pathParameter is the file or directory path. position
// is this parameter allows the caller to upload data in parallel and control the order in which it is appended to the
// file.  It is required when uploading data to be appended to the file and when flushing previously uploaded data to
// the file.  The value must be the position where the data is to be appended.  Uploaded data is not immediately
// flushed, or written, to the file.  To flush, the previously uploaded data must be contiguous, the position parameter
// must be specified and equal to the length of the file after all data has been written, and there must not be a
// request entity body included with the request. retainUncommittedData is valid only for flush operations.  If "true",
// uncommitted data is retained after the flush operation completes; otherwise, the uncommitted data is deleted after
// the flush operation.  The default is false.  Data at offsets less than the specified position are written to the
// file when flush succeeds, but this optional parameter allows data after the flush position to be retained for a
// future flush operation. contentLength is required for "Append Data" and "Flush Data".  Must be 0 for "Flush Data".
// Must be the length of the request content in bytes for "Append Data". xMsLeaseAction is optional.  The lease action
// can be "renew" to renew an existing lease or "release" to release a lease. xMsLeaseID is the lease ID must be
// specified if there is an active lease. xMsCacheControl is optional and only valid for flush and set properties
// operations.  The service stores this value and includes it in the "Cache-Control" response header for "Read File"
// operations. xMsContentType is optional and only valid for flush and set properties operations.  The service stores
// this value and includes it in the "Content-Type" response header for "Read File" operations. xMsContentDisposition
// is optional and only valid for flush and set properties operations.  The service stores this value and includes it
// in the "Content-Disposition" response header for "Read File" operations. xMsContentEncoding is optional and only
// valid for flush and set properties operations.  The service stores this value and includes it in the
// "Content-Encoding" response header for "Read File" operations. xMsContentLanguage is optional and only valid for
// flush and set properties operations.  The service stores this value and includes it in the "Content-Language"
// response header for "Read File" operations. xMsProperties is optional.  User-defined properties to be stored with
// the file or directory, in the format of a comma-separated list of name and value pairs "n1=v1, n2=v2, ...", where
// each value is base64 encoded.  Valid only for the setProperties operation.  If the file or directory exists, any
// properties not included in the list will be removed.  All properties are removed if the header is omitted.  To merge
// new and existing properties, first get all existing properties and the current E-Tag, then make a conditional
// request with the E-Tag and include values for all properties. xMsOwner is optional and valid only for the
// setAccessControl operation. Sets the owner of the file or directory. xMsGroup is optional and valid only for the
// setAccessControl operation. Sets the owning group of the file or directory. xMsPermissions is optional and only
// valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the
// file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also
// supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported. Invalid in conjunction
// with x-ms-acl. xMsACL is optional and valid only for the setAccessControl operation. Sets POSIX access control
// rights on files and directories. The value is a comma-separated list of access control entries that fully replaces
// the existing access control list (ACL).  Each access control entry (ACE) consists of a scope, a type, a user or
// group identifier, and permissions in the format "[scope:][type]:[id]:[permissions]". The scope must be "default" to
// indicate the ACE belongs to the default ACL for a directory; otherwise scope is implicit and the ACE belongs to the
// access ACL.  There are four ACE types: "user" grants rights to the owner or a named user, "group" grants rights to
// the owning group or a named group, "mask" restricts rights granted to named users and the members of groups, and
// "other" grants rights to all users not found in any of the other entries. The user or group identifier is omitted
// for entries of type "mask" and "other".  The user or group identifier is also omitted for the owner and owning
// group.  The permission field is a 3-character sequence where the first character is 'r' to grant read access, the
// second character is 'w' to grant write access, and the third character is 'x' to grant execute permission.  If
// access is not granted, the '-' character is used to denote that the permission is denied. For example, the following
// ACL grants read, write, and execute rights to the file owner and john.doe@contoso, the read right to the owning
// group, and nothing to everyone else: "user::rwx,user:john.doe@contoso:rwx,group::r--,other::---,mask=rwx". Invalid
// in conjunction with x-ms-permissions. ifMatch is optional for Flush Data and Set Properties, but invalid for Append
// Data.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value
// specified. The ETag must be specified in quotes. ifNoneMatch is optional for Flush Data and Set Properties, but
// invalid for Append Data.  An ETag value or the special wildcard ("*") value. Specify this header to perform the
// operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.
// ifModifiedSince is optional for Flush Data and Set Properties, but invalid for Append Data. A date and time value.
// Specify this header to perform the operation only if the resource has been modified since the specified date and
// time. ifUnmodifiedSince is optional for Flush Data and Set Properties, but invalid for Append Data. A date and time
// value. Specify this header to perform the operation only if the resource has not been modified since the specified
// date and time. xHTTPMethodOverride is optional.  Override the http verb on the service side. Some older http clients
// do not support PATCH requestBody is valid only for append operations.  The data to be uploaded and appended to the
// file. requestBody will be closed upon successful return. Callers should ensure closure when receiving an
// error.xMsClientRequestID is a UUID recorded in the analytics logs for troubleshooting and correlation. timeout is an
// optional operation timeout value in seconds. The period begins when the request is received by the service. If the
// timeout value elapses before the operation completes, the operation fails. xMsDate is specifies the Coordinated
// Universal Time (UTC) for the request.  This is required when using shared key authorization.
func (client managementClient) UpdatePath(ctx context.Context, action string, filesystem string, pathParameter string, position *int64, retainUncommittedData *bool, contentLength *string, xMsLeaseAction *string, xMsLeaseID *string, xMsCacheControl *string, xMsContentType *string, xMsContentDisposition *string, xMsContentEncoding *string, xMsContentLanguage *string, xMsProperties *string, xMsOwner *string, xMsGroup *string, xMsPermissions *string, xMsACL *string, ifMatch *string, ifNoneMatch *string, ifModifiedSince *string, ifUnmodifiedSince *string, xHTTPMethodOverride *string, body io.ReadSeeker, xMsClientRequestID *string, timeout *int32, xMsDate *string) (*UpdatePathResponse, error) {
	if err := validate([]validation{
		{targetValue: xMsLeaseID,
			constraints: []constraint{{target: "xMsLeaseID", name: null, rule: false,
				chain: []constraint{{target: "xMsLeaseID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil}}}}},
		{targetValue: filesystem,
			constraints: []constraint{{target: "filesystem", name: maxLength, rule: 63, chain: nil},
				{target: "filesystem", name: minLength, rule: 3, chain: nil}}},
		{targetValue: xMsClientRequestID,
			constraints: []constraint{{target: "xMsClientRequestID", name: null, rule: false,
				chain: []constraint{{target: "xMsClientRequestID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil}}}}},
		{targetValue: timeout,
			constraints: []constraint{{target: "timeout", name: null, rule: false,
				chain: []constraint{{target: "timeout", name: inclusiveMinimum, rule: 1, chain: nil}}}}}}); err != nil {
		return nil, err
	}
	req, err := client.updatePathPreparer(action, filesystem, pathParameter, position, retainUncommittedData, contentLength, xMsLeaseAction, xMsLeaseID, xMsCacheControl, xMsContentType, xMsContentDisposition, xMsContentEncoding, xMsContentLanguage, xMsProperties, xMsOwner, xMsGroup, xMsPermissions, xMsACL, ifMatch, ifNoneMatch, ifModifiedSince, ifUnmodifiedSince, xHTTPMethodOverride, body, xMsClientRequestID, timeout, xMsDate)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.updatePathResponder}, req)
	if err != nil {
		return nil, err
	}
	return resp.(*UpdatePathResponse), err
}

// updatePathPreparer prepares the UpdatePath request.
func (client managementClient) updatePathPreparer(action string, filesystem string, pathParameter string, position *int64, retainUncommittedData *bool, contentLength *string, xMsLeaseAction *string, xMsLeaseID *string, xMsCacheControl *string, xMsContentType *string, xMsContentDisposition *string, xMsContentEncoding *string, xMsContentLanguage *string, xMsProperties *string, xMsOwner *string, xMsGroup *string, xMsPermissions *string, xMsACL *string, ifMatch *string, ifNoneMatch *string, ifModifiedSince *string, ifUnmodifiedSince *string, xHTTPMethodOverride *string, body io.ReadSeeker, xMsClientRequestID *string, timeout *int32, xMsDate *string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("PUT", client.url, body)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
	params := req.URL.Query()
	params.Set("action", action)
	if position != nil {
		params.Set("position", strconv.FormatInt(*position, 10))
	}
	if retainUncommittedData != nil {
		params.Set("retainUncommittedData", strconv.FormatBool(*retainUncommittedData))
	}
	if timeout != nil {
		params.Set("timeout", strconv.FormatInt(int64(*timeout), 10))
	}
	req.URL.RawQuery = params.Encode()
	if contentLength != nil {
		req.Header.Set("Content-Length", *contentLength)
	}
	if xMsLeaseAction != nil {
		req.Header.Set("x-ms-lease-action", *xMsLeaseAction)
	}
	if xMsLeaseID != nil {
		req.Header.Set("x-ms-lease-id", *xMsLeaseID)
	}
	if xMsCacheControl != nil {
		req.Header.Set("x-ms-cache-control", *xMsCacheControl)
	}
	if xMsContentType != nil {
		req.Header.Set("x-ms-content-type", *xMsContentType)
	}
	if xMsContentDisposition != nil {
		req.Header.Set("x-ms-content-disposition", *xMsContentDisposition)
	}
	if xMsContentEncoding != nil {
		req.Header.Set("x-ms-content-encoding", *xMsContentEncoding)
	}
	if xMsContentLanguage != nil {
		req.Header.Set("x-ms-content-language", *xMsContentLanguage)
	}
	if xMsProperties != nil {
		req.Header.Set("x-ms-properties", *xMsProperties)
	}
	if xMsOwner != nil {
		req.Header.Set("x-ms-owner", *xMsOwner)
	}
	if xMsGroup != nil {
		req.Header.Set("x-ms-group", *xMsGroup)
	}
	if xMsPermissions != nil {
		req.Header.Set("x-ms-permissions", *xMsPermissions)
	}
	if xMsACL != nil {
		req.Header.Set("x-ms-acl", *xMsACL)
	}
	if ifMatch != nil {
		req.Header.Set("If-Match", *ifMatch)
	}
	if ifNoneMatch != nil {
		req.Header.Set("If-None-Match", *ifNoneMatch)
	}
	if ifModifiedSince != nil {
		req.Header.Set("If-Modified-Since", *ifModifiedSince)
	}
	if ifUnmodifiedSince != nil {
		req.Header.Set("If-Unmodified-Since", *ifUnmodifiedSince)
	}
	if xHTTPMethodOverride != nil {
		req.Header.Set("x-http-method-override", *xHTTPMethodOverride)
	}
	if xMsClientRequestID != nil {
		req.Header.Set("x-ms-client-request-id", *xMsClientRequestID)
	}
	if xMsDate != nil {
		req.Header.Set("x-ms-date", *xMsDate)
	}
	req.Header.Set("x-ms-version", ServiceVersion)
	return req, nil
}

// updatePathResponder handles the response to the UpdatePath request.
func (client managementClient) updatePathResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK, http.StatusAccepted)
	if resp == nil {
		return nil, err
	}
	io.Copy(ioutil.Discard, resp.Response().Body)
	resp.Response().Body.Close()
	return &UpdatePathResponse{rawResponse: resp.Response()}, err
}
