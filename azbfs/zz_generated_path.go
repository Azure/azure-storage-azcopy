package azbfs

// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
        "net/url"
    "github.com/Azure/azure-pipeline-go/pipeline"
        "net/url"
    "net/http"
        "net/url"
    "context"
        "net/url"
    "strconv"
        "net/url"
    "io"
        "net/url"
    "encoding/json"
        "net/url"
    "io/ioutil"
)

// pathClient is the azure Data Lake Storage provides storage for Hadoop and other big data workloads.
type pathClient struct {
    managementClient
}
// newPathClient creates an instance of the pathClient client.
func newPathClient(url url.URL, p pipeline.Pipeline) pathClient {
    return pathClient{newManagementClient(url, p)}
}

// Create create or rename a file or directory.    By default, the destination is overwritten and if the destination
// already exists and has a lease the lease is broken.  This operation supports conditional HTTP requests.  For more
// information, see [Specifying Conditional Headers for Blob Service
// Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
// To fail if the destination already exists, use a conditional request with If-None-Match: "*".
//
// filesystem is the filesystem identifier. pathParameter is the file or directory path. resource is required only for
// Create File and Create Directory. The value must be "file" or "directory". continuation is optional.  When renaming
// a directory, the number of paths that are renamed with each invocation is limited.  If the number of paths to be
// renamed exceeds this limit, a continuation token is returned in this response header.  When a continuation token is
// returned in the response, it must be specified in a subsequent invocation of the rename operation to continue
// renaming the directory. mode is optional. Valid only when namespace is enabled. This parameter determines the
// behavior of the rename operation. The value must be "legacy" or "posix", and the default value will be "posix".
// cacheControl is optional.  The service stores this value and includes it in the "Cache-Control" response header for
// "Read File" operations for "Read File" operations. contentEncoding is optional.  Specifies which content encodings
// have been applied to the file. This value is returned to the client when the "Read File" operation is performed.
// contentLanguage is optional.  Specifies the natural language used by the intended audience for the file.
// contentDisposition is optional.  The service stores this value and includes it in the "Content-Disposition" response
// header for "Read File" operations. xMsCacheControl is optional.  The service stores this value and includes it in
// the "Cache-Control" response header for "Read File" operations. xMsContentType is optional.  The service stores this
// value and includes it in the "Content-Type" response header for "Read File" operations. xMsContentEncoding is
// optional.  The service stores this value and includes it in the "Content-Encoding" response header for "Read File"
// operations. xMsContentLanguage is optional.  The service stores this value and includes it in the "Content-Language"
// response header for "Read File" operations. xMsContentDisposition is optional.  The service stores this value and
// includes it in the "Content-Disposition" response header for "Read File" operations. xMsRenameSource is an optional
// file or directory to be renamed.  The value must have the following format: "/{filesystem}/{path}".  If
// "x-ms-properties" is specified, the properties will overwrite the existing properties; otherwise, the existing
// properties will be preserved. This value must be a URL percent-encoded string. Note that the string may only contain
// ASCII characters in the ISO-8859-1 character set. xMsLeaseID is optional.  A lease ID for the path specified in the
// URI.  The path to be overwritten must have an active lease and the lease ID must match. xMsSourceLeaseID is optional
// for rename operations.  A lease ID for the source path.  The source path must have an active lease and the lease ID
// must match. xMsProperties is optional.  User-defined properties to be stored with the file or directory, in the
// format of a comma-separated list of name and value pairs "n1=v1, n2=v2, ...", where each value is a base64 encoded
// string. Note that the string may only contain ASCII characters in the ISO-8859-1 character set. xMsPermissions is
// optional and only valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the
// file owner, the file owning group, and others. Each class may be granted read, write, or execute permission.  The
// sticky bit is also supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported.
// xMsUmask is optional and only valid if Hierarchical Namespace is enabled for the account. When creating a file or
// directory and the parent folder does not have a default ACL, the umask restricts the permissions of the file or
// directory to be created.  The resulting permission is given by p & ^u, where p is the permission and u is the umask.
// For example, if p is 0777 and u is 0057, then the resulting permission is 0720.  The default permission is 0777 for
// a directory and 0666 for a file.  The default umask is 0027.  The umask must be specified in 4-digit octal notation
// (e.g. 0766). ifMatch is optional.  An ETag value. Specify this header to perform the operation only if the
// resource's ETag matches the value specified. The ETag must be specified in quotes. ifNoneMatch is optional.  An ETag
// value or the special wildcard ("*") value. Specify this header to perform the operation only if the resource's ETag
// does not match the value specified. The ETag must be specified in quotes. ifModifiedSince is optional. A date and
// time value. Specify this header to perform the operation only if the resource has been modified since the specified
// date and time. ifUnmodifiedSince is optional. A date and time value. Specify this header to perform the operation
// only if the resource has not been modified since the specified date and time. xMsSourceIfMatch is optional.  An ETag
// value. Specify this header to perform the rename operation only if the source's ETag matches the value specified.
// The ETag must be specified in quotes. xMsSourceIfNoneMatch is optional.  An ETag value or the special wildcard ("*")
// value. Specify this header to perform the rename operation only if the source's ETag does not match the value
// specified. The ETag must be specified in quotes. xMsSourceIfModifiedSince is optional. A date and time value.
// Specify this header to perform the rename operation only if the source has been modified since the specified date
// and time. xMsSourceIfUnmodifiedSince is optional. A date and time value. Specify this header to perform the rename
// operation only if the source has not been modified since the specified date and time. xMsClientRequestID is a UUID
// recorded in the analytics logs for troubleshooting and correlation. timeout is an optional operation timeout value
// in seconds. The period begins when the request is received by the service. If the timeout value elapses before the
// operation completes, the operation fails. xMsDate is specifies the Coordinated Universal Time (UTC) for the request.
// This is required when using shared key authorization.
func (client pathClient) Create(ctx context.Context, filesystem string, pathParameter string, resource PathResourceType, continuation *string, mode PathRenameModeType, cacheControl *string, contentEncoding *string, contentLanguage *string, contentDisposition *string, xMsCacheControl *string, xMsContentType *string, xMsContentEncoding *string, xMsContentLanguage *string, xMsContentDisposition *string, xMsRenameSource *string, xMsLeaseID *string, xMsSourceLeaseID *string, xMsProperties *string, xMsPermissions *string, xMsUmask *string, ifMatch *string, ifNoneMatch *string, ifModifiedSince *string, ifUnmodifiedSince *string, xMsSourceIfMatch *string, xMsSourceIfNoneMatch *string, xMsSourceIfModifiedSince *string, xMsSourceIfUnmodifiedSince *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (*PathCreateResponse, error) {
    if err := validate([]validation{
    { targetValue: xMsLeaseID,
     constraints: []constraint{	{target: "xMsLeaseID", name: null, rule: false ,
    chain: []constraint{	{target: "xMsLeaseID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil },
    }}}},
    { targetValue: xMsSourceLeaseID,
     constraints: []constraint{	{target: "xMsSourceLeaseID", name: null, rule: false ,
    chain: []constraint{	{target: "xMsSourceLeaseID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil },
    }}}},
    { targetValue: filesystem,
     constraints: []constraint{	{target: "filesystem", name: maxLength, rule: 63, chain: nil },
    	{target: "filesystem", name: minLength, rule: 3, chain: nil },
    	{target: "filesystem", name: pattern, rule: `^[$a-z0-9](?!.*--)[-a-z0-9]{1,61}[a-z0-9]$`, chain: nil }}},
    { targetValue: xMsClientRequestID,
     constraints: []constraint{	{target: "xMsClientRequestID", name: null, rule: false ,
    chain: []constraint{	{target: "xMsClientRequestID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil },
    }}}},
    { targetValue: timeout,
     constraints: []constraint{	{target: "timeout", name: null, rule: false ,
    chain: []constraint{	{target: "timeout", name: inclusiveMinimum, rule: 1, chain: nil },
    }}}}}); err != nil {
        return nil, err
    }
	req, err := client.createPreparer(filesystem, pathParameter, resource, continuation, mode, cacheControl, contentEncoding, contentLanguage, contentDisposition, xMsCacheControl, xMsContentType, xMsContentEncoding, xMsContentLanguage, xMsContentDisposition, xMsRenameSource, xMsLeaseID, xMsSourceLeaseID, xMsProperties, xMsPermissions, xMsUmask, ifMatch, ifNoneMatch, ifModifiedSince, ifUnmodifiedSince, xMsSourceIfMatch, xMsSourceIfNoneMatch, xMsSourceIfModifiedSince, xMsSourceIfUnmodifiedSince, xMsClientRequestID, timeout, xMsDate)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.createResponder}, req)
    if err != nil {
        return nil, err
    }
	return resp.(*PathCreateResponse), err
}

// createPreparer prepares the Create request.
func (client pathClient) createPreparer(filesystem string, pathParameter string, resource PathResourceType, continuation *string, mode PathRenameModeType, cacheControl *string, contentEncoding *string, contentLanguage *string, contentDisposition *string, xMsCacheControl *string, xMsContentType *string, xMsContentEncoding *string, xMsContentLanguage *string, xMsContentDisposition *string, xMsRenameSource *string, xMsLeaseID *string, xMsSourceLeaseID *string, xMsProperties *string, xMsPermissions *string, xMsUmask *string, ifMatch *string, ifNoneMatch *string, ifModifiedSince *string, ifUnmodifiedSince *string, xMsSourceIfMatch *string, xMsSourceIfNoneMatch *string, xMsSourceIfModifiedSince *string, xMsSourceIfUnmodifiedSince *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("PUT", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
    params := req.URL.Query()
    if resource != PathResourceNone {
        params.Set("resource", string(resource))
    }
    if continuation != nil && len(*continuation) > 0 {
        params.Set("continuation", *continuation)
    }
    if mode != PathRenameModeNone {
        params.Set("mode", string(mode))
    }
    if timeout != nil {
        params.Set("timeout", strconv.FormatInt(int64(*timeout), 10))
    }
        req.URL.RawQuery = params.Encode()
    if cacheControl != nil {
        req.Header.Set("Cache-Control", *cacheControl)
    }
    if contentEncoding != nil {
        req.Header.Set("Content-Encoding", *contentEncoding)
    }
    if contentLanguage != nil {
        req.Header.Set("Content-Language", *contentLanguage)
    }
    if contentDisposition != nil {
        req.Header.Set("Content-Disposition", *contentDisposition)
    }
    if xMsCacheControl != nil {
        req.Header.Set("x-ms-cache-control", *xMsCacheControl)
    }
    if xMsContentType != nil {
        req.Header.Set("x-ms-content-type", *xMsContentType)
    }
    if xMsContentEncoding != nil {
        req.Header.Set("x-ms-content-encoding", *xMsContentEncoding)
    }
    if xMsContentLanguage != nil {
        req.Header.Set("x-ms-content-language", *xMsContentLanguage)
    }
    if xMsContentDisposition != nil {
        req.Header.Set("x-ms-content-disposition", *xMsContentDisposition)
    }
    if xMsRenameSource != nil {
        req.Header.Set("x-ms-rename-source", *xMsRenameSource)
    }
    if xMsLeaseID != nil {
        req.Header.Set("x-ms-lease-id", *xMsLeaseID)
    }
    if xMsSourceLeaseID != nil {
        req.Header.Set("x-ms-source-lease-id", *xMsSourceLeaseID)
    }
    if xMsProperties != nil {
        req.Header.Set("x-ms-properties", *xMsProperties)
    }
    if xMsPermissions != nil {
        req.Header.Set("x-ms-permissions", *xMsPermissions)
    }
    if xMsUmask != nil {
        req.Header.Set("x-ms-umask", *xMsUmask)
    }
    if ifMatch != nil {
        req.Header.Set("If-Match", *ifMatch)
    }
    if ifNoneMatch != nil {
        req.Header.Set("If-None-Match", *ifNoneMatch)
    }
    if ifModifiedSince != nil {
        req.Header.Set("If-Modified-Since", *ifModifiedSince)
    }
    if ifUnmodifiedSince != nil {
        req.Header.Set("If-Unmodified-Since", *ifUnmodifiedSince)
    }
    if xMsSourceIfMatch != nil {
        req.Header.Set("x-ms-source-if-match", *xMsSourceIfMatch)
    }
    if xMsSourceIfNoneMatch != nil {
        req.Header.Set("x-ms-source-if-none-match", *xMsSourceIfNoneMatch)
    }
    if xMsSourceIfModifiedSince != nil {
        req.Header.Set("x-ms-source-if-modified-since", *xMsSourceIfModifiedSince)
    }
    if xMsSourceIfUnmodifiedSince != nil {
        req.Header.Set("x-ms-source-if-unmodified-since", *xMsSourceIfUnmodifiedSince)
    }
    if xMsClientRequestID != nil {
        req.Header.Set("x-ms-client-request-id", *xMsClientRequestID)
    }
    if xMsDate != nil {
        req.Header.Set("x-ms-date", *xMsDate)
    }
    if xMsVersion != nil {
        req.Header.Set("x-ms-version", *client.XMsVersion)
    }
	return req, nil
}

// createResponder handles the response to the Create request.
func (client pathClient) createResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK,http.StatusCreated)
	if resp == nil {
		return nil, err
	}
    io.Copy(ioutil.Discard, resp.Response().Body)
    resp.Response().Body.Close()
        return &PathCreateResponse{rawResponse: resp.Response()}, err
}

// Delete delete the file or directory. This operation supports conditional HTTP requests.  For more information, see
// [Specifying Conditional Headers for Blob Service
// Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
//
// filesystem is the filesystem identifier. pathParameter is the file or directory path. recursive is required and
// valid only when the resource is a directory.  If "true", all paths beneath the directory will be deleted. If "false"
// and the directory is non-empty, an error occurs. continuation is optional.  When deleting a directory, the number of
// paths that are deleted with each invocation is limited.  If the number of paths to be deleted exceeds this limit, a
// continuation token is returned in this response header.  When a continuation token is returned in the response, it
// must be specified in a subsequent invocation of the delete operation to continue deleting the directory. xMsLeaseID
// is the lease ID must be specified if there is an active lease. ifMatch is optional.  An ETag value. Specify this
// header to perform the operation only if the resource's ETag matches the value specified. The ETag must be specified
// in quotes. ifNoneMatch is optional.  An ETag value or the special wildcard ("*") value. Specify this header to
// perform the operation only if the resource's ETag does not match the value specified. The ETag must be specified in
// quotes. ifModifiedSince is optional. A date and time value. Specify this header to perform the operation only if the
// resource has been modified since the specified date and time. ifUnmodifiedSince is optional. A date and time value.
// Specify this header to perform the operation only if the resource has not been modified since the specified date and
// time. xMsClientRequestID is a UUID recorded in the analytics logs for troubleshooting and correlation. timeout is an
// optional operation timeout value in seconds. The period begins when the request is received by the service. If the
// timeout value elapses before the operation completes, the operation fails. xMsDate is specifies the Coordinated
// Universal Time (UTC) for the request.  This is required when using shared key authorization.
func (client pathClient) Delete(ctx context.Context, filesystem string, pathParameter string, recursive *bool, continuation *string, xMsLeaseID *string, ifMatch *string, ifNoneMatch *string, ifModifiedSince *string, ifUnmodifiedSince *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (*PathDeleteResponse, error) {
    if err := validate([]validation{
    { targetValue: xMsLeaseID,
     constraints: []constraint{	{target: "xMsLeaseID", name: null, rule: false ,
    chain: []constraint{	{target: "xMsLeaseID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil },
    }}}},
    { targetValue: filesystem,
     constraints: []constraint{	{target: "filesystem", name: maxLength, rule: 63, chain: nil },
    	{target: "filesystem", name: minLength, rule: 3, chain: nil },
    	{target: "filesystem", name: pattern, rule: `^[$a-z0-9](?!.*--)[-a-z0-9]{1,61}[a-z0-9]$`, chain: nil }}},
    { targetValue: xMsClientRequestID,
     constraints: []constraint{	{target: "xMsClientRequestID", name: null, rule: false ,
    chain: []constraint{	{target: "xMsClientRequestID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil },
    }}}},
    { targetValue: timeout,
     constraints: []constraint{	{target: "timeout", name: null, rule: false ,
    chain: []constraint{	{target: "timeout", name: inclusiveMinimum, rule: 1, chain: nil },
    }}}}}); err != nil {
        return nil, err
    }
	req, err := client.deletePreparer(filesystem, pathParameter, recursive, continuation, xMsLeaseID, ifMatch, ifNoneMatch, ifModifiedSince, ifUnmodifiedSince, xMsClientRequestID, timeout, xMsDate)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.deleteResponder}, req)
    if err != nil {
        return nil, err
    }
	return resp.(*PathDeleteResponse), err
}

// deletePreparer prepares the Delete request.
func (client pathClient) deletePreparer(filesystem string, pathParameter string, recursive *bool, continuation *string, xMsLeaseID *string, ifMatch *string, ifNoneMatch *string, ifModifiedSince *string, ifUnmodifiedSince *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("DELETE", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
    params := req.URL.Query()
    if recursive != nil {
        params.Set("recursive", strconv.FormatBool(*recursive))
    }
    if continuation != nil && len(*continuation) > 0 {
        params.Set("continuation", *continuation)
    }
    if timeout != nil {
        params.Set("timeout", strconv.FormatInt(int64(*timeout), 10))
    }
        req.URL.RawQuery = params.Encode()
    if xMsLeaseID != nil {
        req.Header.Set("x-ms-lease-id", *xMsLeaseID)
    }
    if ifMatch != nil {
        req.Header.Set("If-Match", *ifMatch)
    }
    if ifNoneMatch != nil {
        req.Header.Set("If-None-Match", *ifNoneMatch)
    }
    if ifModifiedSince != nil {
        req.Header.Set("If-Modified-Since", *ifModifiedSince)
    }
    if ifUnmodifiedSince != nil {
        req.Header.Set("If-Unmodified-Since", *ifUnmodifiedSince)
    }
    if xMsClientRequestID != nil {
        req.Header.Set("x-ms-client-request-id", *xMsClientRequestID)
    }
    if xMsDate != nil {
        req.Header.Set("x-ms-date", *xMsDate)
    }
    if xMsVersion != nil {
        req.Header.Set("x-ms-version", *client.XMsVersion)
    }
	return req, nil
}

// deleteResponder handles the response to the Delete request.
func (client pathClient) deleteResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
    io.Copy(ioutil.Discard, resp.Response().Body)
    resp.Response().Body.Close()
        return &PathDeleteResponse{rawResponse: resp.Response()}, err
}

// GetProperties get Properties returns all system and user defined properties for a path. Get Status returns all
// system defined properties for a path. Get Access Control List returns the access control list for a path. This
// operation supports conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob
// Service
// Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
//
// filesystem is the filesystem identifier. pathParameter is the file or directory path. action is optional. If the
// value is "getStatus" only the system defined properties for the path are returned. If the value is
// "getAccessControl" the access control list is returned in the response headers (Hierarchical Namespace must be
// enabled for the account), otherwise the properties are returned. upn is optional. Valid only when Hierarchical
// Namespace is enabled for the account. If "true", the user identity values returned in the x-ms-owner, x-ms-group,
// and x-ms-acl response headers will be transformed from Azure Active Directory Object IDs to User Principal Names.
// If "false", the values will be returned as Azure Active Directory Object IDs. The default value is false. Note that
// group and application Object IDs are not translated because they do not have unique friendly names. xMsLeaseID is
// optional. If this header is specified, the operation will be performed only if both of the following conditions are
// met: i) the path's lease is currently active and ii) the lease ID specified in the request matches that of the path.
// ifMatch is optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag
// matches the value specified. The ETag must be specified in quotes. ifNoneMatch is optional.  An ETag value or the
// special wildcard ("*") value. Specify this header to perform the operation only if the resource's ETag does not
// match the value specified. The ETag must be specified in quotes. ifModifiedSince is optional. A date and time value.
// Specify this header to perform the operation only if the resource has been modified since the specified date and
// time. ifUnmodifiedSince is optional. A date and time value. Specify this header to perform the operation only if the
// resource has not been modified since the specified date and time. xMsClientRequestID is a UUID recorded in the
// analytics logs for troubleshooting and correlation. timeout is an optional operation timeout value in seconds. The
// period begins when the request is received by the service. If the timeout value elapses before the operation
// completes, the operation fails. xMsDate is specifies the Coordinated Universal Time (UTC) for the request.  This is
// required when using shared key authorization.
func (client pathClient) GetProperties(ctx context.Context, filesystem string, pathParameter string, action PathGetPropertiesActionType, upn *bool, xMsLeaseID *string, ifMatch *string, ifNoneMatch *string, ifModifiedSince *string, ifUnmodifiedSince *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (*PathGetPropertiesResponse, error) {
    if err := validate([]validation{
    { targetValue: xMsLeaseID,
     constraints: []constraint{	{target: "xMsLeaseID", name: null, rule: false ,
    chain: []constraint{	{target: "xMsLeaseID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil },
    }}}},
    { targetValue: filesystem,
     constraints: []constraint{	{target: "filesystem", name: maxLength, rule: 63, chain: nil },
    	{target: "filesystem", name: minLength, rule: 3, chain: nil },
    	{target: "filesystem", name: pattern, rule: `^[$a-z0-9](?!.*--)[-a-z0-9]{1,61}[a-z0-9]$`, chain: nil }}},
    { targetValue: xMsClientRequestID,
     constraints: []constraint{	{target: "xMsClientRequestID", name: null, rule: false ,
    chain: []constraint{	{target: "xMsClientRequestID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil },
    }}}},
    { targetValue: timeout,
     constraints: []constraint{	{target: "timeout", name: null, rule: false ,
    chain: []constraint{	{target: "timeout", name: inclusiveMinimum, rule: 1, chain: nil },
    }}}}}); err != nil {
        return nil, err
    }
	req, err := client.getPropertiesPreparer(filesystem, pathParameter, action, upn, xMsLeaseID, ifMatch, ifNoneMatch, ifModifiedSince, ifUnmodifiedSince, xMsClientRequestID, timeout, xMsDate)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getPropertiesResponder}, req)
    if err != nil {
        return nil, err
    }
	return resp.(*PathGetPropertiesResponse), err
}

// getPropertiesPreparer prepares the GetProperties request.
func (client pathClient) getPropertiesPreparer(filesystem string, pathParameter string, action PathGetPropertiesActionType, upn *bool, xMsLeaseID *string, ifMatch *string, ifNoneMatch *string, ifModifiedSince *string, ifUnmodifiedSince *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("HEAD", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
    params := req.URL.Query()
    if action != PathGetPropertiesActionNone {
        params.Set("action", string(action))
    }
    if upn != nil {
        params.Set("upn", strconv.FormatBool(*upn))
    }
    if timeout != nil {
        params.Set("timeout", strconv.FormatInt(int64(*timeout), 10))
    }
        req.URL.RawQuery = params.Encode()
    if xMsLeaseID != nil {
        req.Header.Set("x-ms-lease-id", *xMsLeaseID)
    }
    if ifMatch != nil {
        req.Header.Set("If-Match", *ifMatch)
    }
    if ifNoneMatch != nil {
        req.Header.Set("If-None-Match", *ifNoneMatch)
    }
    if ifModifiedSince != nil {
        req.Header.Set("If-Modified-Since", *ifModifiedSince)
    }
    if ifUnmodifiedSince != nil {
        req.Header.Set("If-Unmodified-Since", *ifUnmodifiedSince)
    }
    if xMsClientRequestID != nil {
        req.Header.Set("x-ms-client-request-id", *xMsClientRequestID)
    }
    if xMsDate != nil {
        req.Header.Set("x-ms-date", *xMsDate)
    }
    if xMsVersion != nil {
        req.Header.Set("x-ms-version", *client.XMsVersion)
    }
	return req, nil
}

// getPropertiesResponder handles the response to the GetProperties request.
func (client pathClient) getPropertiesResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
    io.Copy(ioutil.Discard, resp.Response().Body)
    resp.Response().Body.Close()
        return &PathGetPropertiesResponse{rawResponse: resp.Response()}, err
}

// Lease create and manage a lease to restrict write and delete access to the path. This operation supports conditional
// HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service
// Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
//
// xMsLeaseAction is there are five lease actions: "acquire", "break", "change", "renew", and "release". Use "acquire"
// and specify the "x-ms-proposed-lease-id" and "x-ms-lease-duration" to acquire a new lease. Use "break" to break an
// existing lease. When a lease is broken, the lease break period is allowed to elapse, during which time no lease
// operation except break and release can be performed on the file. When a lease is successfully broken, the response
// indicates the interval in seconds until a new lease can be acquired. Use "change" and specify the current lease ID
// in "x-ms-lease-id" and the new lease ID in "x-ms-proposed-lease-id" to change the lease ID of an active lease. Use
// "renew" and specify the "x-ms-lease-id" to renew an existing lease. Use "release" and specify the "x-ms-lease-id" to
// release a lease. filesystem is the filesystem identifier. pathParameter is the file or directory path.
// xMsLeaseDuration is the lease duration is required to acquire a lease, and specifies the duration of the lease in
// seconds.  The lease duration must be between 15 and 60 seconds or -1 for infinite lease. xMsLeaseBreakPeriod is the
// lease break period duration is optional to break a lease, and  specifies the break period of the lease in seconds.
// The lease break  duration must be between 0 and 60 seconds. xMsLeaseID is required when "x-ms-lease-action" is
// "renew", "change" or "release". For the renew and release actions, this must match the current lease ID.
// xMsProposedLeaseID is required when "x-ms-lease-action" is "acquire" or "change".  A lease will be acquired with
// this lease ID if the operation is successful. ifMatch is optional.  An ETag value. Specify this header to perform
// the operation only if the resource's ETag matches the value specified. The ETag must be specified in quotes.
// ifNoneMatch is optional.  An ETag value or the special wildcard ("*") value. Specify this header to perform the
// operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.
// ifModifiedSince is optional. A date and time value. Specify this header to perform the operation only if the
// resource has been modified since the specified date and time. ifUnmodifiedSince is optional. A date and time value.
// Specify this header to perform the operation only if the resource has not been modified since the specified date and
// time. xMsClientRequestID is a UUID recorded in the analytics logs for troubleshooting and correlation. timeout is an
// optional operation timeout value in seconds. The period begins when the request is received by the service. If the
// timeout value elapses before the operation completes, the operation fails. xMsDate is specifies the Coordinated
// Universal Time (UTC) for the request.  This is required when using shared key authorization.
func (client pathClient) Lease(ctx context.Context, xMsLeaseAction PathLeaseActionType, filesystem string, pathParameter string, xMsLeaseDuration *int32, xMsLeaseBreakPeriod *int32, xMsLeaseID *string, xMsProposedLeaseID *string, ifMatch *string, ifNoneMatch *string, ifModifiedSince *string, ifUnmodifiedSince *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (*PathLeaseResponse, error) {
    if err := validate([]validation{
    { targetValue: xMsLeaseID,
     constraints: []constraint{	{target: "xMsLeaseID", name: null, rule: false ,
    chain: []constraint{	{target: "xMsLeaseID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil },
    }}}},
    { targetValue: xMsProposedLeaseID,
     constraints: []constraint{	{target: "xMsProposedLeaseID", name: null, rule: false ,
    chain: []constraint{	{target: "xMsProposedLeaseID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil },
    }}}},
    { targetValue: filesystem,
     constraints: []constraint{	{target: "filesystem", name: maxLength, rule: 63, chain: nil },
    	{target: "filesystem", name: minLength, rule: 3, chain: nil },
    	{target: "filesystem", name: pattern, rule: `^[$a-z0-9](?!.*--)[-a-z0-9]{1,61}[a-z0-9]$`, chain: nil }}},
    { targetValue: xMsClientRequestID,
     constraints: []constraint{	{target: "xMsClientRequestID", name: null, rule: false ,
    chain: []constraint{	{target: "xMsClientRequestID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil },
    }}}},
    { targetValue: timeout,
     constraints: []constraint{	{target: "timeout", name: null, rule: false ,
    chain: []constraint{	{target: "timeout", name: inclusiveMinimum, rule: 1, chain: nil },
    }}}}}); err != nil {
        return nil, err
    }
	req, err := client.leasePreparer(xMsLeaseAction, filesystem, pathParameter, xMsLeaseDuration, xMsLeaseBreakPeriod, xMsLeaseID, xMsProposedLeaseID, ifMatch, ifNoneMatch, ifModifiedSince, ifUnmodifiedSince, xMsClientRequestID, timeout, xMsDate)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.leaseResponder}, req)
    if err != nil {
        return nil, err
    }
	return resp.(*PathLeaseResponse), err
}

// leasePreparer prepares the Lease request.
func (client pathClient) leasePreparer(xMsLeaseAction PathLeaseActionType, filesystem string, pathParameter string, xMsLeaseDuration *int32, xMsLeaseBreakPeriod *int32, xMsLeaseID *string, xMsProposedLeaseID *string, ifMatch *string, ifNoneMatch *string, ifModifiedSince *string, ifUnmodifiedSince *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("POST", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
    params := req.URL.Query()
    if timeout != nil {
        params.Set("timeout", strconv.FormatInt(int64(*timeout), 10))
    }
        req.URL.RawQuery = params.Encode()
    req.Header.Set("x-ms-lease-action", string(xMsLeaseAction))
    if xMsLeaseDuration != nil {
        req.Header.Set("x-ms-lease-duration", strconv.FormatInt(int64(*xMsLeaseDuration), 10))
    }
    if xMsLeaseBreakPeriod != nil {
        req.Header.Set("x-ms-lease-break-period", strconv.FormatInt(int64(*xMsLeaseBreakPeriod), 10))
    }
    if xMsLeaseID != nil {
        req.Header.Set("x-ms-lease-id", *xMsLeaseID)
    }
    if xMsProposedLeaseID != nil {
        req.Header.Set("x-ms-proposed-lease-id", *xMsProposedLeaseID)
    }
    if ifMatch != nil {
        req.Header.Set("If-Match", *ifMatch)
    }
    if ifNoneMatch != nil {
        req.Header.Set("If-None-Match", *ifNoneMatch)
    }
    if ifModifiedSince != nil {
        req.Header.Set("If-Modified-Since", *ifModifiedSince)
    }
    if ifUnmodifiedSince != nil {
        req.Header.Set("If-Unmodified-Since", *ifUnmodifiedSince)
    }
    if xMsClientRequestID != nil {
        req.Header.Set("x-ms-client-request-id", *xMsClientRequestID)
    }
    if xMsDate != nil {
        req.Header.Set("x-ms-date", *xMsDate)
    }
    if xMsVersion != nil {
        req.Header.Set("x-ms-version", *client.XMsVersion)
    }
	return req, nil
}

// leaseResponder handles the response to the Lease request.
func (client pathClient) leaseResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK,http.StatusCreated,http.StatusAccepted)
	if resp == nil {
		return nil, err
	}
    io.Copy(ioutil.Discard, resp.Response().Body)
    resp.Response().Body.Close()
        return &PathLeaseResponse{rawResponse: resp.Response()}, err
}

// List list filesystem paths and their properties.
//
// recursive is if "true", all paths are listed; otherwise, only paths at the root of the filesystem are listed.  If
// "directory" is specified, the list will only include paths that share the same root. filesystem is the filesystem
// identifier.  The value must start and end with a letter or number and must contain only letters, numbers, and the
// dash (-) character.  Consecutive dashes are not permitted.  All letters must be lowercase.  The value must have
// between 3 and 63 characters. directory is filters results to paths within the specified directory. An error occurs
// if the directory does not exist. continuation is the number of paths returned with each invocation is limited. If
// the number of paths to be returned exceeds this limit, a continuation token is returned in the response header
// x-ms-continuation. When a continuation token is  returned in the response, it must be specified in a subsequent
// invocation of the list operation to continue listing the paths. maxResults is an optional value that specifies the
// maximum number of items to return. If omitted or greater than 5,000, the response will include up to 5,000 items.
// upn is optional. Valid only when Hierarchical Namespace is enabled for the account. If "true", the user identity
// values returned in the owner and group fields of each list entry will be transformed from Azure Active Directory
// Object IDs to User Principal Names.  If "false", the values will be returned as Azure Active Directory Object IDs.
// The default value is false. Note that group and application Object IDs are not translated because they do not have
// unique friendly names. xMsClientRequestID is a UUID recorded in the analytics logs for troubleshooting and
// correlation. timeout is an optional operation timeout value in seconds. The period begins when the request is
// received by the service. If the timeout value elapses before the operation completes, the operation fails. xMsDate
// is specifies the Coordinated Universal Time (UTC) for the request.  This is required when using shared key
// authorization.
func (client pathClient) List(ctx context.Context, recursive bool, filesystem string, directory *string, continuation *string, maxResults *int32, upn *bool, xMsClientRequestID *string, timeout *int32, xMsDate *string) (*PathList, error) {
    if err := validate([]validation{
    { targetValue: maxResults,
     constraints: []constraint{	{target: "maxResults", name: null, rule: false ,
    chain: []constraint{	{target: "maxResults", name: inclusiveMinimum, rule: 1, chain: nil },
    }}}},
    { targetValue: filesystem,
     constraints: []constraint{	{target: "filesystem", name: maxLength, rule: 63, chain: nil },
    	{target: "filesystem", name: minLength, rule: 3, chain: nil },
    	{target: "filesystem", name: pattern, rule: `^[$a-z0-9](?!.*--)[-a-z0-9]{1,61}[a-z0-9]$`, chain: nil }}},
    { targetValue: xMsClientRequestID,
     constraints: []constraint{	{target: "xMsClientRequestID", name: null, rule: false ,
    chain: []constraint{	{target: "xMsClientRequestID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil },
    }}}},
    { targetValue: timeout,
     constraints: []constraint{	{target: "timeout", name: null, rule: false ,
    chain: []constraint{	{target: "timeout", name: inclusiveMinimum, rule: 1, chain: nil },
    }}}}}); err != nil {
        return nil, err
    }
	req, err := client.listPreparer(recursive, filesystem, directory, continuation, maxResults, upn, xMsClientRequestID, timeout, xMsDate)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.listResponder}, req)
    if err != nil {
        return nil, err
    }
	return resp.(*PathList), err
}

// listPreparer prepares the List request.
func (client pathClient) listPreparer(recursive bool, filesystem string, directory *string, continuation *string, maxResults *int32, upn *bool, xMsClientRequestID *string, timeout *int32, xMsDate *string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
    params := req.URL.Query()
    if directory != nil && len(*directory) > 0 {
        params.Set("directory", *directory)
    }
        params.Set("recursive", strconv.FormatBool(recursive))
    if continuation != nil && len(*continuation) > 0 {
        params.Set("continuation", *continuation)
    }
    if maxResults != nil {
        params.Set("maxResults", strconv.FormatInt(int64(*maxResults), 10))
    }
    if upn != nil {
        params.Set("upn", strconv.FormatBool(*upn))
    }
        params.Set("resource", "filesystem")
    if timeout != nil {
        params.Set("timeout", strconv.FormatInt(int64(*timeout), 10))
    }
        req.URL.RawQuery = params.Encode()
    if xMsClientRequestID != nil {
        req.Header.Set("x-ms-client-request-id", *xMsClientRequestID)
    }
    if xMsDate != nil {
        req.Header.Set("x-ms-date", *xMsDate)
    }
    if xMsVersion != nil {
        req.Header.Set("x-ms-version", *client.XMsVersion)
    }
	return req, nil
}

// listResponder handles the response to the List request.
func (client pathClient) listResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK)
	if resp == nil {
		return nil, err
	}
    result:= &PathList{rawResponse: resp.Response()}
    if err != nil {
        return result, err
    }
    defer resp.Response().Body.Close()
    b, err:= ioutil.ReadAll(resp.Response().Body)
    if err != nil {
        return result, err
    }
    if len(b) > 0 {
        b = removeBOM(b)
        err = json.Unmarshal(b, result)
        if err != nil {
            return result, NewResponseError(err, resp.Response(), "failed to unmarshal response body")
        }
    }
    return result, nil
}

// Read read the contents of a file.  For read operations, range requests are supported. This operation supports
// conditional HTTP requests.  For more information, see [Specifying Conditional Headers for Blob Service
// Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
//
// filesystem is the filesystem identifier. pathParameter is the file or directory path. rangeParameter is the HTTP
// Range request header specifies one or more byte ranges of the resource to be retrieved. xMsLeaseID is optional. If
// this header is specified, the operation will be performed only if both of the following conditions are met: i) the
// path's lease is currently active and ii) the lease ID specified in the request matches that of the path. ifMatch is
// optional.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value
// specified. The ETag must be specified in quotes. ifNoneMatch is optional.  An ETag value or the special wildcard
// ("*") value. Specify this header to perform the operation only if the resource's ETag does not match the value
// specified. The ETag must be specified in quotes. ifModifiedSince is optional. A date and time value. Specify this
// header to perform the operation only if the resource has been modified since the specified date and time.
// ifUnmodifiedSince is optional. A date and time value. Specify this header to perform the operation only if the
// resource has not been modified since the specified date and time. xMsClientRequestID is a UUID recorded in the
// analytics logs for troubleshooting and correlation. timeout is an optional operation timeout value in seconds. The
// period begins when the request is received by the service. If the timeout value elapses before the operation
// completes, the operation fails. xMsDate is specifies the Coordinated Universal Time (UTC) for the request.  This is
// required when using shared key authorization.
func (client pathClient) Read(ctx context.Context, filesystem string, pathParameter string, rangeParameter *string, xMsLeaseID *string, ifMatch *string, ifNoneMatch *string, ifModifiedSince *string, ifUnmodifiedSince *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (*ReadResponse, error) {
    if err := validate([]validation{
    { targetValue: xMsLeaseID,
     constraints: []constraint{	{target: "xMsLeaseID", name: null, rule: false ,
    chain: []constraint{	{target: "xMsLeaseID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil },
    }}}},
    { targetValue: filesystem,
     constraints: []constraint{	{target: "filesystem", name: maxLength, rule: 63, chain: nil },
    	{target: "filesystem", name: minLength, rule: 3, chain: nil },
    	{target: "filesystem", name: pattern, rule: `^[$a-z0-9](?!.*--)[-a-z0-9]{1,61}[a-z0-9]$`, chain: nil }}},
    { targetValue: xMsClientRequestID,
     constraints: []constraint{	{target: "xMsClientRequestID", name: null, rule: false ,
    chain: []constraint{	{target: "xMsClientRequestID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil },
    }}}},
    { targetValue: timeout,
     constraints: []constraint{	{target: "timeout", name: null, rule: false ,
    chain: []constraint{	{target: "timeout", name: inclusiveMinimum, rule: 1, chain: nil },
    }}}}}); err != nil {
        return nil, err
    }
	req, err := client.readPreparer(filesystem, pathParameter, rangeParameter, xMsLeaseID, ifMatch, ifNoneMatch, ifModifiedSince, ifUnmodifiedSince, xMsClientRequestID, timeout, xMsDate)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.readResponder}, req)
    if err != nil {
        return nil, err
    }
	return resp.(*ReadResponse), err
}

// readPreparer prepares the Read request.
func (client pathClient) readPreparer(filesystem string, pathParameter string, rangeParameter *string, xMsLeaseID *string, ifMatch *string, ifNoneMatch *string, ifModifiedSince *string, ifUnmodifiedSince *string, xMsClientRequestID *string, timeout *int32, xMsDate *string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("GET", client.url, nil)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
    params := req.URL.Query()
    if timeout != nil {
        params.Set("timeout", strconv.FormatInt(int64(*timeout), 10))
    }
        req.URL.RawQuery = params.Encode()
    if rangeParameter != nil {
        req.Header.Set("Range", *rangeParameter)
    }
    if xMsLeaseID != nil {
        req.Header.Set("x-ms-lease-id", *xMsLeaseID)
    }
    if ifMatch != nil {
        req.Header.Set("If-Match", *ifMatch)
    }
    if ifNoneMatch != nil {
        req.Header.Set("If-None-Match", *ifNoneMatch)
    }
    if ifModifiedSince != nil {
        req.Header.Set("If-Modified-Since", *ifModifiedSince)
    }
    if ifUnmodifiedSince != nil {
        req.Header.Set("If-Unmodified-Since", *ifUnmodifiedSince)
    }
    if xMsClientRequestID != nil {
        req.Header.Set("x-ms-client-request-id", *xMsClientRequestID)
    }
    if xMsDate != nil {
        req.Header.Set("x-ms-date", *xMsDate)
    }
    if xMsVersion != nil {
        req.Header.Set("x-ms-version", *client.XMsVersion)
    }
	return req, nil
}

// readResponder handles the response to the Read request.
func (client pathClient) readResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK,http.StatusPartialContent)
	if resp == nil {
		return nil, err
	}
    return &ReadResponse{rawResponse: resp.Response()}, err
}

// Update uploads data to be appended to a file, flushes (writes) previously uploaded data to a file, sets properties
// for a file or directory, or sets access control for a file or directory. Data can only be appended to a file. This
// operation supports conditional HTTP requests. For more information, see [Specifying Conditional Headers for Blob
// Service
// Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
//
// action is the action must be "append" to upload data to be appended to a file, "flush" to flush previously uploaded
// data to a file, "setProperties" to set the properties of a file or directory, or "setAccessControl" to set the
// owner, group, permissions, or access control list for a file or directory.  Note that Hierarchical Namespace must be
// enabled for the account in order to use access control.  Also note that the Access Control List (ACL) includes
// permissions for the owner, owning group, and others, so the x-ms-permissions and x-ms-acl request headers are
// mutually exclusive. filesystem is the filesystem identifier. pathParameter is the file or directory path. position
// is this parameter allows the caller to upload data in parallel and control the order in which it is appended to the
// file.  It is required when uploading data to be appended to the file and when flushing previously uploaded data to
// the file.  The value must be the position where the data is to be appended.  Uploaded data is not immediately
// flushed, or written, to the file.  To flush, the previously uploaded data must be contiguous, the position parameter
// must be specified and equal to the length of the file after all data has been written, and there must not be a
// request entity body included with the request. retainUncommittedData is valid only for flush operations.  If "true",
// uncommitted data is retained after the flush operation completes; otherwise, the uncommitted data is deleted after
// the flush operation.  The default is false.  Data at offsets less than the specified position are written to the
// file when flush succeeds, but this optional parameter allows data after the flush position to be retained for a
// future flush operation. closeParameter is azure Storage Events allow applications to receive notifications when
// files change. When Azure Storage Events are enabled, a file changed event is raised. This event has a property
// indicating whether this is the final change to distinguish the difference between an intermediate flush to a file
// stream and the final close of a file stream. The close query parameter is valid only when the action is "flush" and
// change notifications are enabled. If the value of close is "true" and the flush operation completes successfully,
// the service raises a file change notification with a property indicating that this is the final update (the file
// stream has been closed). If "false" a change notification is raised indicating the file has changed. The default is
// false. This query parameter is set to true by the Hadoop ABFS driver to indicate that the file stream has been
// closed." contentLength is required for "Append Data" and "Flush Data".  Must be 0 for "Flush Data".  Must be the
// length of the request content in bytes for "Append Data". xMsLeaseID is the lease ID must be specified if there is
// an active lease. xMsCacheControl is optional and only valid for flush and set properties operations.  The service
// stores this value and includes it in the "Cache-Control" response header for "Read File" operations. xMsContentType
// is optional and only valid for flush and set properties operations.  The service stores this value and includes it
// in the "Content-Type" response header for "Read File" operations. xMsContentDisposition is optional and only valid
// for flush and set properties operations.  The service stores this value and includes it in the "Content-Disposition"
// response header for "Read File" operations. xMsContentEncoding is optional and only valid for flush and set
// properties operations.  The service stores this value and includes it in the "Content-Encoding" response header for
// "Read File" operations. xMsContentLanguage is optional and only valid for flush and set properties operations.  The
// service stores this value and includes it in the "Content-Language" response header for "Read File" operations.
// xMsContentMd5 is optional and only valid for "Flush & Set Properties" operations.  The service stores this value and
// includes it in the "Content-Md5" response header for "Read & Get Properties" operations. If this property is not
// specified on the request, then the property will be cleared for the file. Subsequent calls to "Read & Get
// Properties" will not return this property unless it is explicitly set on that file again. xMsProperties is optional.
// User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and
// value pairs "n1=v1, n2=v2, ...", where each value is a base64 encoded string. Note that the string may only contain
// ASCII characters in the ISO-8859-1 character set. Valid only for the setProperties operation. If the file or
// directory exists, any properties not included in the list will be removed.  All properties are removed if the header
// is omitted.  To merge new and existing properties, first get all existing properties and the current E-Tag, then
// make a conditional request with the E-Tag and include values for all properties. xMsOwner is optional and valid only
// for the setAccessControl operation. Sets the owner of the file or directory. xMsGroup is optional and valid only for
// the setAccessControl operation. Sets the owning group of the file or directory. xMsPermissions is optional and only
// valid if Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the
// file owning group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also
// supported.  Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported. Invalid in conjunction
// with x-ms-acl. xMsACL is optional and valid only for the setAccessControl operation. Sets POSIX access control
// rights on files and directories. The value is a comma-separated list of access control entries that fully replaces
// the existing access control list (ACL).  Each access control entry (ACE) consists of a scope, a type, a user or
// group identifier, and permissions in the format "[scope:][type]:[id]:[permissions]". The scope must be "default" to
// indicate the ACE belongs to the default ACL for a directory; otherwise scope is implicit and the ACE belongs to the
// access ACL.  There are four ACE types: "user" grants rights to the owner or a named user, "group" grants rights to
// the owning group or a named group, "mask" restricts rights granted to named users and the members of groups, and
// "other" grants rights to all users not found in any of the other entries. The user or group identifier is omitted
// for entries of type "mask" and "other".  The user or group identifier is also omitted for the owner and owning
// group.  The permission field is a 3-character sequence where the first character is 'r' to grant read access, the
// second character is 'w' to grant write access, and the third character is 'x' to grant execute permission.  If
// access is not granted, the '-' character is used to denote that the permission is denied. For example, the following
// ACL grants read, write, and execute rights to the file owner and john.doe@contoso, the read right to the owning
// group, and nothing to everyone else: "user::rwx,user:john.doe@contoso:rwx,group::r--,other::---,mask=rwx". Invalid
// in conjunction with x-ms-permissions. ifMatch is optional for Flush Data and Set Properties, but invalid for Append
// Data.  An ETag value. Specify this header to perform the operation only if the resource's ETag matches the value
// specified. The ETag must be specified in quotes. ifNoneMatch is optional for Flush Data and Set Properties, but
// invalid for Append Data.  An ETag value or the special wildcard ("*") value. Specify this header to perform the
// operation only if the resource's ETag does not match the value specified. The ETag must be specified in quotes.
// ifModifiedSince is optional for Flush Data and Set Properties, but invalid for Append Data. A date and time value.
// Specify this header to perform the operation only if the resource has been modified since the specified date and
// time. ifUnmodifiedSince is optional for Flush Data and Set Properties, but invalid for Append Data. A date and time
// value. Specify this header to perform the operation only if the resource has not been modified since the specified
// date and time. requestBody is valid only for append operations.  The data to be uploaded and appended to the file.
// requestBody will be closed upon successful return. Callers should ensure closure when receiving an
// error.xMsClientRequestID is a UUID recorded in the analytics logs for troubleshooting and correlation. timeout is an
// optional operation timeout value in seconds. The period begins when the request is received by the service. If the
// timeout value elapses before the operation completes, the operation fails. xMsDate is specifies the Coordinated
// Universal Time (UTC) for the request.  This is required when using shared key authorization.
func (client pathClient) Update(ctx context.Context, action PathUpdateActionType, filesystem string, pathParameter string, position *int64, retainUncommittedData *bool, closeParameter *bool, contentLength *int64, xMsLeaseID *string, xMsCacheControl *string, xMsContentType *string, xMsContentDisposition *string, xMsContentEncoding *string, xMsContentLanguage *string, xMsContentMd5 *string, xMsProperties *string, xMsOwner *string, xMsGroup *string, xMsPermissions *string, xMsACL *string, ifMatch *string, ifNoneMatch *string, ifModifiedSince *string, ifUnmodifiedSince *string, body io.ReadSeeker, xMsClientRequestID *string, timeout *int32, xMsDate *string) (*PathUpdateResponse, error) {
    if err := validate([]validation{
    { targetValue: contentLength,
     constraints: []constraint{	{target: "contentLength", name: null, rule: false ,
    chain: []constraint{	{target: "contentLength", name: inclusiveMinimum, rule: 0, chain: nil },
    }}}},
    { targetValue: xMsLeaseID,
     constraints: []constraint{	{target: "xMsLeaseID", name: null, rule: false ,
    chain: []constraint{	{target: "xMsLeaseID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil },
    }}}},
    { targetValue: filesystem,
     constraints: []constraint{	{target: "filesystem", name: maxLength, rule: 63, chain: nil },
    	{target: "filesystem", name: minLength, rule: 3, chain: nil },
    	{target: "filesystem", name: pattern, rule: `^[$a-z0-9](?!.*--)[-a-z0-9]{1,61}[a-z0-9]$`, chain: nil }}},
    { targetValue: xMsClientRequestID,
     constraints: []constraint{	{target: "xMsClientRequestID", name: null, rule: false ,
    chain: []constraint{	{target: "xMsClientRequestID", name: pattern, rule: `^[{(]?[0-9a-f]{8}[-]?([0-9a-f]{4}[-]?){3}[0-9a-f]{12}[)}]?$`, chain: nil },
    }}}},
    { targetValue: timeout,
     constraints: []constraint{	{target: "timeout", name: null, rule: false ,
    chain: []constraint{	{target: "timeout", name: inclusiveMinimum, rule: 1, chain: nil },
    }}}}}); err != nil {
        return nil, err
    }
	req, err := client.updatePreparer(action, filesystem, pathParameter, position, retainUncommittedData, closeParameter, contentLength, xMsLeaseID, xMsCacheControl, xMsContentType, xMsContentDisposition, xMsContentEncoding, xMsContentLanguage, xMsContentMd5, xMsProperties, xMsOwner, xMsGroup, xMsPermissions, xMsACL, ifMatch, ifNoneMatch, ifModifiedSince, ifUnmodifiedSince, body, xMsClientRequestID, timeout, xMsDate)
	if err != nil {
		return nil, err
	}
	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.updateResponder}, req)
    if err != nil {
        return nil, err
    }
	return resp.(*PathUpdateResponse), err
}

// updatePreparer prepares the Update request.
func (client pathClient) updatePreparer(action PathUpdateActionType, filesystem string, pathParameter string, position *int64, retainUncommittedData *bool, closeParameter *bool, contentLength *int64, xMsLeaseID *string, xMsCacheControl *string, xMsContentType *string, xMsContentDisposition *string, xMsContentEncoding *string, xMsContentLanguage *string, xMsContentMd5 *string, xMsProperties *string, xMsOwner *string, xMsGroup *string, xMsPermissions *string, xMsACL *string, ifMatch *string, ifNoneMatch *string, ifModifiedSince *string, ifUnmodifiedSince *string, body io.ReadSeeker, xMsClientRequestID *string, timeout *int32, xMsDate *string) (pipeline.Request, error) {
	req, err := pipeline.NewRequest("PATCH", client.url, body)
	if err != nil {
		return req, pipeline.NewError(err, "failed to create request")
	}
    params := req.URL.Query()
    params.Set("action", string(action))
    if position != nil {
        params.Set("position", strconv.FormatInt(*position, 10))
    }
    if retainUncommittedData != nil {
        params.Set("retainUncommittedData", strconv.FormatBool(*retainUncommittedData))
    }
    if closeParameter != nil {
        params.Set("close", strconv.FormatBool(*closeParameter))
    }
    if timeout != nil {
        params.Set("timeout", strconv.FormatInt(int64(*timeout), 10))
    }
        req.URL.RawQuery = params.Encode()
    if contentLength != nil {
        req.Header.Set("Content-Length", strconv.FormatInt(*contentLength, 10))
    }
    if xMsLeaseID != nil {
        req.Header.Set("x-ms-lease-id", *xMsLeaseID)
    }
    if xMsCacheControl != nil {
        req.Header.Set("x-ms-cache-control", *xMsCacheControl)
    }
    if xMsContentType != nil {
        req.Header.Set("x-ms-content-type", *xMsContentType)
    }
    if xMsContentDisposition != nil {
        req.Header.Set("x-ms-content-disposition", *xMsContentDisposition)
    }
    if xMsContentEncoding != nil {
        req.Header.Set("x-ms-content-encoding", *xMsContentEncoding)
    }
    if xMsContentLanguage != nil {
        req.Header.Set("x-ms-content-language", *xMsContentLanguage)
    }
    if xMsContentMd5 != nil {
        req.Header.Set("x-ms-content-md5", *xMsContentMd5)
    }
    if xMsProperties != nil {
        req.Header.Set("x-ms-properties", *xMsProperties)
    }
    if xMsOwner != nil {
        req.Header.Set("x-ms-owner", *xMsOwner)
    }
    if xMsGroup != nil {
        req.Header.Set("x-ms-group", *xMsGroup)
    }
    if xMsPermissions != nil {
        req.Header.Set("x-ms-permissions", *xMsPermissions)
    }
    if xMsACL != nil {
        req.Header.Set("x-ms-acl", *xMsACL)
    }
    if ifMatch != nil {
        req.Header.Set("If-Match", *ifMatch)
    }
    if ifNoneMatch != nil {
        req.Header.Set("If-None-Match", *ifNoneMatch)
    }
    if ifModifiedSince != nil {
        req.Header.Set("If-Modified-Since", *ifModifiedSince)
    }
    if ifUnmodifiedSince != nil {
        req.Header.Set("If-Unmodified-Since", *ifUnmodifiedSince)
    }
    if xMsClientRequestID != nil {
        req.Header.Set("x-ms-client-request-id", *xMsClientRequestID)
    }
    if xMsDate != nil {
        req.Header.Set("x-ms-date", *xMsDate)
    }
    if xMsVersion != nil {
        req.Header.Set("x-ms-version", *client.XMsVersion)
    }
	return req, nil
}

// updateResponder handles the response to the Update request.
func (client pathClient) updateResponder(resp pipeline.Response) (pipeline.Response, error) {
	err := validateResponse(resp, http.StatusOK,http.StatusAccepted)
	if resp == nil {
		return nil, err
	}
    io.Copy(ioutil.Discard, resp.Response().Body)
    resp.Response().Body.Close()
        return &PathUpdateResponse{rawResponse: resp.Response()}, err
}

